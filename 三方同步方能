import sys
import time
import re
import urllib
import threading
import configparser
import requests
from functools import partial
from bs4 import BeautifulSoup

from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QTextEdit, QPushButton, QFormLayout, QMessageBox, QGroupBox, QStackedWidget,
    QListWidget, QListWidgetItem
)

CONFIG_FILE = 'config.ini'

# === æ™ºèƒ½æ¨¡å¼è§¦å‘é¢‘ç‡ï¼ˆåˆ†é’Ÿï¼‰ ===
INTERVAL_MIN = 2       # æƒ³æ¯ N åˆ†é’Ÿè§¦å‘å°±å¡« Nï¼ˆä¾‹å¦‚ 2 / 5 / 10ï¼‰
ALIGN_MINUTE = 0       # åç§»åˆ†é’Ÿï¼ˆ0=åœ¨ 00,02,04â€¦è§¦å‘ï¼›1=åœ¨ 01,03,05â€¦è§¦å‘ï¼‰


class App(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("æ–¹èƒ½åŒæ­¥å·¥å…·ï¼ˆä¾§è¾¹å¯¼èˆªç‰ˆï¼‰")
        self.resize(880, 700)

        self.fields = {}           # ç»Ÿä¸€ç®¡ç†æ‰€æœ‰è¾“å…¥æ§ä»¶
        self.long_text_field = 'æ–¹èƒ½_cookie'

        self._build_ui()
        self._load_config()

        # æ–¹èƒ½ Cookie è½®è¯¢çº¿ç¨‹ï¼ˆä¿æŒç™»å½•æ€ï¼‰
        self.polling_thread = threading.Thread(target=self._poll_and_check_cookie_loop, daemon=True)
        self.polling_thread.start()

    # ===================== UI æ„å»º =====================
    def _build_ui(self):
        root = QHBoxLayout(self)

        # å·¦ä¾§å¯¼èˆª
        self.nav = QListWidget()
        self.nav.setFixedWidth(170)
        self.nav.addItem(QListWidgetItem("ğŸ¢ æ–¹èƒ½é…ç½®"))
        self.nav.addItem(QListWidgetItem("ğŸŒˆ å¤©é¸¿é…ç½®"))
        self.nav.currentRowChanged.connect(self._on_nav_changed)

        # å³ä¾§é¡µé¢
        self.pages = QStackedWidget()
        self.pages.addWidget(self._build_page_fangneng())
        self.pages.addWidget(self._build_page_tianhong())

        root.addWidget(self.nav)
        root.addWidget(self.pages, 1)

        # é»˜è®¤é€‰ä¸­ç¬¬ä¸€é¡µ
        self.nav.setCurrentRow(0)

        # æ™ºèƒ½æ¨¡å¼å®šæ—¶å™¨
        self.smart_timer = QTimer()
        self.smart_timer.timeout.connect(self._check_and_run_smart_mode)
        self.smart_mode_enabled = False

    def _on_nav_changed(self, idx: int):
        self.pages.setCurrentIndex(idx)

    # ========== Page 1ï¼šæ–¹èƒ½é…ç½® ==========
    def _build_page_fangneng(self) -> QWidget:
        page = QWidget()
        main_layout = QVBoxLayout(page)

        # æ–¹èƒ½å¹³å°é…ç½®
        group_fn = QGroupBox("ğŸ¢ æ–¹èƒ½å¹³å°é…ç½®")
        form_fn = QFormLayout()
        for name in ['æ–¹èƒ½è´¦å·', 'æ–¹èƒ½å¯†ç ', 'æ–¹èƒ½éªŒè¯ç ', 'æ–¹èƒ½åŸŸå', 'user-agent', 'æ–¹èƒ½_cookie']:
            label = QLabel(name)
            widget = QTextEdit() if name == self.long_text_field else QLineEdit()

            if name in ('æ–¹èƒ½è´¦å·', 'æ–¹èƒ½å¯†ç ') and isinstance(widget, QLineEdit):
                widget.setEchoMode(QLineEdit.Password)

            if name == self.long_text_field:
                widget.setFixedHeight(80)

            form_fn.addRow(label, widget)
            self.fields[name] = widget
        group_fn.setLayout(form_fn)

        # Telegram
        group_tg = QGroupBox("ğŸ¤– Telegram é€šçŸ¥")
        form_tg = QFormLayout()
        for name in ['æœºå™¨äººToken', 'ç¾¤ç»„ID']:
            label = QLabel(name)
            widget = QLineEdit()
            form_tg.addRow(label, widget)
            self.fields[name] = widget
        group_tg.setLayout(form_tg)

        # æ“ä½œæŒ‰é’®ï¼ˆåªä¿ç•™å››ä¸ªï¼‰
        btn_row = QHBoxLayout()
        btn_save = QPushButton("ğŸ’¾ ä¿å­˜é…ç½®")
        btn_save.clicked.connect(self._save_config)

        btn_run = QPushButton("ğŸš€ è¿è¡Œç¨‹åº")
        btn_run.clicked.connect(self._run_all_sync_threaded)

        btn_smart = QPushButton(f"ğŸ§  æ™ºèƒ½æ¨¡å¼ï¼ˆæ¯{INTERVAL_MIN}åˆ†é’Ÿï¼‰")
        btn_smart.setCheckable(True)
        btn_smart.clicked.connect(self._toggle_smart_mode)

        btn_login = QPushButton("ğŸ” ç™»å½•è·å–cookie")
        btn_login.clicked.connect(self._login_fangneng_and_update_cookie)

        btn_row.addWidget(btn_save)
        btn_row.addWidget(btn_run)
        btn_row.addWidget(btn_smart)
        btn_row.addWidget(btn_login)
        btn_row.addStretch()

        main_layout.addWidget(group_fn)
        main_layout.addWidget(group_tg)
        main_layout.addLayout(btn_row)
        main_layout.addStretch()
        return page

    # ========== Page 2ï¼šå¤©é¸¿é…ç½®ï¼ˆä»…é…ç½®é¡¹ï¼Œæ— æŒ‰é’®ï¼‰ ==========
    def _build_page_tianhong(self) -> QWidget:
        page = QWidget()
        main_layout = QVBoxLayout(page)

        group_th = QGroupBox("ğŸŒˆ å¤©é¸¿å¹³å°è®¾ç½®")
        form_th = QFormLayout()
        # ä»…ä¿ç•™åŸŸåï¼ˆportï¼‰å’Œ cookie
        for name in ['å¤©é¸¿åŸŸå(port)', 'å¤©é¸¿cookie']:
            label = QLabel(name)
            widget = QLineEdit()
            form_th.addRow(label, widget)
            self.fields[name] = widget
        group_th.setLayout(form_th)

        tips = QLabel("è¯´æ˜ï¼šæœ¬é¡µä»…é…ç½®é¡¹ã€‚ç‚¹å‡»â€œæ–¹èƒ½é…ç½®â€é¡µçš„ã€ä¿å­˜é…ç½®ã€ã€è¿è¡Œç¨‹åºã€ã€æ™ºèƒ½æ¨¡å¼ã€å››ä¸ªæŒ‰é’®ç»Ÿä¸€ç®¡ç†ã€‚")
        tips.setWordWrap(True)

        main_layout.addWidget(group_th)
        main_layout.addWidget(tips)
        main_layout.addStretch()
        return page

    # ===================== æ™ºèƒ½æ¨¡å¼ =====================
    def _toggle_smart_mode(self, checked: bool):
        self.smart_mode_enabled = checked
        if checked:
            QMessageBox.information(self, "æ™ºèƒ½æ¨¡å¼", f"âœ… æ™ºèƒ½æ¨¡å¼å·²å¼€å¯ï¼Œå°†æ¯ {INTERVAL_MIN} åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ã€‚")
            # æ¯ 10 ç§’æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦åˆ°è§¦å‘çª—å£
            self.smart_timer.start(10_000)
        else:
            QMessageBox.information(self, "æ™ºèƒ½æ¨¡å¼", "â›”ï¸ æ™ºèƒ½æ¨¡å¼å·²å…³é—­ã€‚")
            self.smart_timer.stop()

    def _check_and_run_smart_mode(self):
        now = time.localtime()
        if (now.tm_min - ALIGN_MINUTE) % INTERVAL_MIN == 0 and now.tm_sec < 10:
            print("â° æ™ºèƒ½æ¨¡å¼è§¦å‘ï¼Œå¼€å§‹è¿è¡Œç¨‹åºï¼ˆç»Ÿä¸€åŒæ­¥ï¼‰...")
            self._run_all_sync_threaded()

    # ============== æ–¹èƒ½ Cookie è‡ªåŠ¨ç»´æŠ¤ï¼ˆä¿æŒç™»å½•æ€ï¼‰ ==============
    def _poll_and_check_cookie_loop(self):
        while True:
            try:
                domain = self._get_value('æ–¹èƒ½åŸŸå')
                user_agent = self._get_value('user-agent')
                current_cookie = self._get_value('æ–¹èƒ½_cookie', is_text=True).strip()

                if not domain or not current_cookie:
                    print("â³ [è½®è¯¢] Cookie æˆ–åŸŸåä¸ºç©ºï¼Œè·³è¿‡æœ¬è½®ã€‚")
                    time.sleep(60)
                    continue

                headers = {
                    'user-agent': user_agent,
                    'x-requested-with': 'XMLHttpRequest',
                    'cookie': current_cookie
                }

                url = f"https://{domain}/PassManage/Pass/GetPageListJson?page=1&limit=10"
                res = requests.get(url, headers=headers, timeout=10)
                print("ğŸ“¦ [è½®è¯¢] æ–¹èƒ½å“åº”çŠ¶æ€ç ï¼š", res.status_code)

                set_cookie = res.headers.get("Set-Cookie", "")
                match = re.search(r'UserToken=([^;]+)', set_cookie)
                if match:
                    new_token = match.group(1)
                    new_cookie = f"UserToken={new_token}"

                    decoded_old = urllib.parse.unquote(current_cookie.replace("UserToken=", "").strip())
                    decoded_new = urllib.parse.unquote(new_token.strip())

                    if decoded_new != decoded_old:
                        print("ğŸ” [è½®è¯¢] æ£€æµ‹åˆ° Cookie æ›´æ–°ï¼Œè‡ªåŠ¨æ›¿æ¢")
                        QTimer.singleShot(0, partial(self._update_cookie_ui, new_cookie))
                        QTimer.singleShot(0, partial(QMessageBox.information,
                                                     self, "Cookie æ›´æ–°", "ğŸ” æ£€æµ‹åˆ°æ–°çš„ UserTokenï¼Œå·²è‡ªåŠ¨æ›´æ–°ï¼"))
                    else:
                        print("âœ… [è½®è¯¢] Cookie å†…å®¹ä¸€è‡´")
                else:
                    print("â„¹ï¸ [è½®è¯¢] å“åº”ä¸­æ—  Set-Cookie")

            except Exception as e:
                print("âš ï¸ [è½®è¯¢] æ£€æŸ¥å¼‚å¸¸ï¼š", str(e))

            print("ğŸ•’ [è½®è¯¢] ç­‰å¾… 5 åˆ†é’Ÿåç»§ç»­...")
            time.sleep(5 * 60)

    def _update_cookie_ui(self, cookie_value: str):
        w = self.fields.get('æ–¹èƒ½_cookie')
        if isinstance(w, QTextEdit):
            w.setPlainText(cookie_value)

    # ============== æ–¹èƒ½ç™»å½•è·å– Cookie ==============
    def _login_fangneng_and_update_cookie(self):
        username = self._get_value('æ–¹èƒ½è´¦å·')
        password = self._get_value('æ–¹èƒ½å¯†ç ')
        googlecode = self._get_value('æ–¹èƒ½éªŒè¯ç ')
        domain = self._get_value('æ–¹èƒ½åŸŸå')
        user_agent = self._get_value('user-agent')

        session = requests.Session()
        headers = {
            'user-agent': user_agent,
            'x-requested-with': 'XMLHttpRequest',
        }

        try:
            session.get(f"https://{domain}/Home/Login", headers=headers, timeout=5)
            data = {'username': username, 'password': password, 'googlecode': googlecode}
            res = session.post(f"https://{domain}/Home/LoginJson", headers=headers, data=data, timeout=10)
            token = session.cookies.get("UserToken")
            if token:
                self._set_value('æ–¹èƒ½_cookie', f"UserToken={token}", is_text=True)
                QMessageBox.information(self, "ç™»å½•æˆåŠŸ", f"âœ… ç™»å½•æˆåŠŸï¼Œå·²è·å– UserTokenã€‚\n{token}")
            else:
                QMessageBox.critical(self, "ç™»å½•å¤±è´¥", f"âŒ ç™»å½•å¤±è´¥ï¼Œå“åº”å†…å®¹ï¼š\n{res.text}")
        except Exception as e:
            QMessageBox.critical(self, "å¼‚å¸¸", f"âš ï¸ ç™»å½•è¯·æ±‚å¼‚å¸¸ï¼š{str(e)}")

    # ===================== é…ç½®å­˜å–ï¼ˆç»Ÿä¸€ä¿å­˜æ‰€æœ‰é¡µé¢ï¼‰ =====================
    def _save_config(self):
        config = configparser.ConfigParser(interpolation=None)
        config['DEFAULT'] = {
            k: (v.toPlainText() if isinstance(v, QTextEdit) else v.text())
            for k, v in self.fields.items()
        }
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                config.write(f)
            QMessageBox.information(self, "æˆåŠŸ", "é…ç½®å·²ä¿å­˜åˆ° config.iniï¼ˆå·²ä¿å­˜æ‰€æœ‰å¹³å°é…ç½®ï¼‰")
        except Exception as e:
            QMessageBox.critical(self, "é”™è¯¯", f"ä¿å­˜å¤±è´¥: {e}")

    def _load_config(self):
        config = configparser.ConfigParser(interpolation=None)
        try:
            config.read(CONFIG_FILE, encoding='utf-8')
            for k, w in self.fields.items():
                if k in config['DEFAULT']:
                    if isinstance(w, QTextEdit):
                        w.setPlainText(config['DEFAULT'][k])
                    else:
                        w.setText(config['DEFAULT'][k])
        except Exception as e:
            QMessageBox.warning(self, "è­¦å‘Š", f"åŠ è½½é…ç½®å¤±è´¥: {e}")

    # ===================== å·¥å…·å‡½æ•° =====================
    def _get_value(self, key: str, is_text: bool = False) -> str:
        w = self.fields.get(key)
        if not w:
            return ""
        if is_text and isinstance(w, QTextEdit):
            return w.toPlainText()
        return w.text() if hasattr(w, 'text') else ""

    def _set_value(self, key: str, val: str, is_text: bool = False):
        w = self.fields.get(key)
        if not w:
            return
        if is_text and isinstance(w, QTextEdit):
            w.setPlainText(val)
        elif hasattr(w, 'setText'):
            w.setText(val)

    # ===================== Telegram =====================
    def _send_telegram(self, message: str):
        bot_token = self._get_value('æœºå™¨äººToken')
        chat_id = self._get_value('ç¾¤ç»„ID')
        if not bot_token or not chat_id:
            print("âš ï¸ æœªé…ç½® Telegram ä¿¡æ¯ï¼Œè·³è¿‡å‘é€ã€‚")
            return
        url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
        data = {'chat_id': chat_id, 'text': message, 'parse_mode': 'Markdown'}
        try:
            requests.post(url, data=data, timeout=8)
        except Exception as e:
            print(f"å‘é€ Telegram æ¶ˆæ¯å¤±è´¥: {e}")

    # ===================== ç»Ÿä¸€â€œè¿è¡Œç¨‹åºâ€å…¥å£ =====================
    def _run_all_sync_threaded(self):
        t = threading.Thread(target=self._run_all_sync, daemon=True)
        t.start()

    def _run_all_sync(self):
        self._send_telegram("âœ… ç¨‹åºå¯åŠ¨ï¼šç»Ÿä¸€åŒæ­¥ä»»åŠ¡å¼€å§‹")
        # å¤©é¸¿ â†’ æ–¹èƒ½
        self._run_tianhong_to_fangneng()

    # ===================== å¤©é¸¿â†’æ–¹èƒ½ ä¸»æµç¨‹ =====================
    def _run_tianhong_to_fangneng(self):
        # è¯»å–é…ç½®
        th_host = self._get_value('å¤©é¸¿åŸŸå(port)').strip()
        th_cookie = self._get_value('å¤©é¸¿cookie').strip()

        fn_domain = self._get_value('æ–¹èƒ½åŸŸå').strip()
        fn_ua = self._get_value('user-agent').strip()
        fn_cookie = self._get_value('æ–¹èƒ½_cookie', is_text=True).strip()

        if not th_host or not th_cookie or not fn_domain or not fn_ua or not fn_cookie:
            QMessageBox.warning(self, "ç¼ºå°‘é…ç½®", "è¯·å…ˆå¡«å†™å¤©é¸¿åŸŸå/cookie ä»¥åŠæ–¹èƒ½åŸŸå/UA/Cookieã€‚")
            return

        # self._send_telegram("â–¶ï¸ å¼€å§‹ï¼š*å¤©é¸¿* â†’ *æ–¹èƒ½*ï¼ˆä»…æ›´æ–°æ–¹èƒ½å·²å­˜åœ¨çš„â€œå¤©é¸¿â€é€šé“ï¼‰")

        # 1) å¤©é¸¿æŠ“å–
        print("ğŸŸ¡ [å¤©é¸¿] å¼€å§‹æŠ“å–...")
        tianhong_url = f"https://{th_host}/user_Channel_index.html"
        th_headers = {'cookie': th_cookie}
        tianhong_map = {}  # {code: rate_decimal_4}

        try:
            html = self._tianhong_get_html(tianhong_url, th_headers)
            for code, rate_raw in self._tianhong_extract_rows(html):
                try:
                    rate_val = self._normalize_rate_to_decimal_4(rate_raw)  # '17.5%' -> 0.1750
                    tianhong_map[str(code).strip()] = rate_val
                except Exception as e:
                    print(f"âš ï¸ [å¤©é¸¿] è´¹ç‡è§£æå¤±è´¥ ({code}, {rate_raw}): {e}")
            print(f"âœ… [å¤©é¸¿] æŠ“å–å®Œæˆï¼Œé€šé“æ•°ï¼š{len(tianhong_map)}")
        except Exception as e:
            print(f"âŒ [å¤©é¸¿] æŠ“å–å¼‚å¸¸ï¼š{e}")

        if not tianhong_map:
            self._send_telegram("âš ï¸ [å¤©é¸¿] æŠ“å–ä¸ºç©ºï¼Œåœæ­¢æœ¬æ¬¡åŒæ­¥ã€‚")
            return

        # 2) æŸ¥è¯¢æ–¹èƒ½ â€œå¤©é¸¿â€ åä¸‹é€šé“
        print("ğŸŸ¡ [æ–¹èƒ½] å¼€å§‹æŸ¥è¯¢â€œå¤©é¸¿â€é€šé“...")
        æŸ¥è¯¢æ¥å£ = f'https://{fn_domain}/PassManage/Pass/GetPageListJson'
        æ›´æ–°æ¥å£ = f'https://{fn_domain}/PassManage/Pass/EditChannelTypeConf'
        headers_fn = {'cookie': fn_cookie, 'user-agent': fn_ua, 'x-requested-with': 'XMLHttpRequest'}

        fangneng_items = {}
        page, limit = 1, 100
        while True:
            params = {'page': str(page), 'limit': str(limit), 'name': 'å¤©é¸¿', 'tGGroupId': '', 'state': '1'}
            try:
                r = requests.get(æŸ¥è¯¢æ¥å£, params=params, headers=headers_fn, timeout=12)
                if r.status_code != 200:
                    print(f"âŒ [æ–¹èƒ½] æŸ¥è¯¢å¤±è´¥ï¼ŒçŠ¶æ€ç : {r.status_code}")
                    break
                js = r.json()
                page_data = js.get('PageData', []) or js.get('data', []) or []
                if not page_data:
                    break
                for it in page_data:
                    ch_type = str(it.get('ChannelType', '')).strip()
                    if ch_type:
                        fangneng_items[ch_type] = it
                if len(page_data) < limit:
                    break
                page += 1
            except Exception as e:
                print(f"âš ï¸ [æ–¹èƒ½] æŸ¥è¯¢å¼‚å¸¸ï¼š{e}")
                break

        print(f"âœ… [æ–¹èƒ½] å‘½ä¸­â€œå¤©é¸¿â€é€šé“æ•°ï¼š{len(fangneng_items)}")
        if not fangneng_items:
            self._send_telegram("âš ï¸ [æ–¹èƒ½] æœªæ‰¾åˆ°åç§°ä¸ºâ€œå¤©é¸¿â€çš„é€šé“ã€‚")
            return

        # 3) æ¯”å¯¹ & æ›´æ–°
        print("ğŸŸ¡ å¼€å§‹é€æ¡æ›´æ–°ï¼ˆä»…è´¹ç‡ä¸ä¸€è‡´æ‰æ›´æ–°ï¼Œé—´éš”1ç§’ï¼‰...")
        æˆåŠŸæ•°é‡ = 0
        è·³è¿‡æ•°é‡ = 0
        æœªåŒ¹é…æ•°é‡ = 0
        æˆåŠŸåˆ—è¡¨ = []

        for ch_code, item in fangneng_items.items():
            target_rate = tianhong_map.get(ch_code)
            if target_rate is None:
                æœªåŒ¹é…æ•°é‡ += 1
                print(f"â­ [æœªåŒ¹é…] æ–¹èƒ½æœ‰ç¼–ç  {ch_code}ï¼Œå¤©é¸¿æœªæä¾›ï¼Œè·³è¿‡")
                continue

            current_rate_raw = str(item.get('PassChannelTypeConfRate', '')).strip()
            try:
                current_rate = round(float(current_rate_raw), 4)
            except Exception:
                try:
                    if current_rate_raw.endswith('%'):
                        current_rate = round(float(current_rate_raw[:-1].strip()) / 100.0, 4)
                    else:
                        current_rate = round(float(current_rate_raw), 4)
                except Exception as e:
                    print(f"âš ï¸ [è´¹ç‡å¼‚å¸¸] ç¼–ç  {ch_code} å½“å‰è´¹ç‡æ— æ³•è§£æ({current_rate_raw})ï¼š{e}ï¼Œè·³è¿‡")
                    è·³è¿‡æ•°é‡ += 1
                    continue

            if current_rate == target_rate:
                print(f"â­ ç¼–ç  {ch_code} è´¹ç‡ä¸€è‡´ï¼ˆ{current_rate:.4f}ï¼‰ï¼Œè·³è¿‡")
                è·³è¿‡æ•°é‡ += 1
                continue

            payload = {
                'Id': item.get('PassChannelTypeConfId'),
                'Status': '1',
                'PassId': '',
                'remark': item.get('PassCodeName'),
                'Rate': f"{target_rate:.4f}",       # å°æ•°å½¢å¼ï¼Œå››ä½
                'AmountRange': item.get('AmountRange'),
                'ChannelType': item.get('ChannelType'),
                'AgentRate': '0',
            }
            try:
                res = requests.post(æ›´æ–°æ¥å£, data=payload, headers=headers_fn, timeout=12)
                if res.status_code == 200:
                    æˆåŠŸæ•°é‡ += 1
                    æˆåŠŸåˆ—è¡¨.append(f"{ch_code} {current_rate:.4f} â†’ {target_rate:.4f}")
                    print(f"âœ… ç¼–ç  {ch_code} æ›´æ–°æˆåŠŸï¼š{current_rate:.4f} â†’ {target_rate:.4f}")
                else:
                    print(f"âŒ æ›´æ–°å¤±è´¥ ç¼–ç  {ch_code}ï¼ŒHTTP {res.status_code}ï¼Œè¿”å›ï¼š{res.text[:200]}")
                time.sleep(1)
            except Exception as e:
                print(f"âš ï¸ æ›´æ–°å¼‚å¸¸ ç¼–ç  {ch_code}ï¼š{e}")

        æ˜ç»†æ–‡æœ¬ = "æ— " if not æˆåŠŸåˆ—è¡¨ else "\n".join(æˆåŠŸåˆ—è¡¨[:50])
        msg = (
            f"ğŸ“¢ *å¤©é¸¿â†’æ–¹èƒ½ è´¹ç‡åŒæ­¥å®Œæˆ*\n"
            f"âœ… æˆåŠŸæ›´æ–°ï¼š*{æˆåŠŸæ•°é‡}*\n"
            f"â­ è´¹ç‡ä¸€è‡´è·³è¿‡ï¼š*{è·³è¿‡æ•°é‡}*\n"
            f"â“ æ–¹èƒ½æœ‰ä½†å¤©é¸¿æ— ï¼ˆè·³è¿‡ï¼‰ï¼š*{æœªåŒ¹é…æ•°é‡}*\n"
            f"ğŸ“¦ æ–¹èƒ½â€œå¤©é¸¿â€é€šé“æ€»æ•°ï¼š*{len(fangneng_items)}*\n"
            f"ğŸ§¾ æ›´æ–°æ˜ç»†ï¼ˆå‰50æ¡ï¼‰ï¼š\n{æ˜ç»†æ–‡æœ¬}\n"
            f"â° æ—¶é—´ï¼š{time.strftime('%Y-%m-%d %H:%M:%S')}"
        )
        # æ”¹ä¸ºï¼šåªæœ‰æœ‰å®é™…æ›´æ–°æ—¶æ‰å‘
        if æˆåŠŸæ•°é‡ > 0:
            self._send_telegram(msg)

        # UI æç¤º
        def show_finish():
            QMessageBox.information(
                self, "å®Œæˆ",
                f"âœ… æˆåŠŸæ›´æ–°ï¼š{æˆåŠŸæ•°é‡} æ¡\n"
                f"â­ è´¹ç‡ä¸€è‡´ï¼š{è·³è¿‡æ•°é‡} æ¡\n"
                f"â“ æ–¹èƒ½æœ‰ä½†å¤©é¸¿æ— ï¼š{æœªåŒ¹é…æ•°é‡} æ¡\n"
                f"ğŸ“¦ æ–¹èƒ½â€œå¤©é¸¿â€é€šé“ï¼š{len(fangneng_items)} æ¡"
            )
        QTimer.singleShot(0, show_finish)

    # ===================== å¤©é¸¿æŠ“å–å·¥å…· =====================
    @staticmethod
    def _tianhong_get_html(url: str, headers: dict) -> str:
        resp = requests.get(url, headers=headers, timeout=20)
        resp.raise_for_status()
        if not resp.encoding or resp.encoding.lower() == "iso-8859-1":
            resp.encoding = resp.apparent_encoding or "utf-8"
        return resp.text

    @staticmethod
    def _tianhong_extract_rows(html: str):
        """
        è§£æè¡¨æ ¼ï¼Œè¿”å› (é€šé“ç¼–ç , é€šé“è´¹ç‡åŸå§‹å­—ç¬¦ä¸²)ï¼Œä¾‹å¦‚ ('2008', '17.5%')
        """
        soup = BeautifulSoup(html, "html.parser")
        tables = soup.select("table.layui-table")
        for tbl in tables:
            thead = tbl.find("thead")
            if not thead:
                continue
            head_text = " ".join(thead.get_text(separator=" ", strip=True).split())
            if all(k in head_text for k in ["é€šé“ç¼–ç ", "é€šé“è´¹ç‡"]):
                tbody = tbl.find("tbody")
                if not tbody:
                    continue
                for tr in tbody.find_all("tr"):
                    tds = tr.find_all("td")
                    if len(tds) < 3:
                        continue
                    code = tds[0].get_text(strip=True)
                    rate = tds[2].get_text(strip=True)
                    if code:
                        yield code, rate

    @staticmethod
    def _normalize_rate_to_decimal_4(rate_str: str) -> float:
        """
        '17.5%' / '17.5' / '17' -> 0.1750ï¼ˆå››èˆäº”å…¥åˆ° 4 ä½ï¼‰
        """
        s = (rate_str or "").strip()
        if s.endswith('%'):
            s = s[:-1].strip()
        s = s.replace(',', '')
        v = float(s) / 100.0
        return round(v, 4)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = App()
    w.show()
    sys.exit(app.exec_())
