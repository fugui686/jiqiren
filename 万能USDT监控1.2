import sys
import os
import time
import random
import hashlib
import configparser
import html
from datetime import datetime, time as dtime
from decimal import Decimal, ROUND_DOWN
from typing import Optional, Dict, List, Set, Tuple
from PyQt5.QtCore import QByteArray
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt5.QtGui import QIntValidator, QDoubleValidator
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLineEdit, QLabel, QPushButton,
    QVBoxLayout, QHBoxLayout, QFormLayout, QGroupBox, QPlainTextEdit,
    QMessageBox, QCheckBox
)

import requests


# ===================== Âü∫Á°ÄÈÖçÁΩÆ =====================

def get_base_dir() -> str:
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


BASE_DIR = get_base_dir()
CONFIG_FILE = os.path.join(BASE_DIR, "config.ini")
WHITELIST_FILE = os.path.join(BASE_DIR, "wallet_whitelist.txt")

MAX_LOG_LINES = 2000
FIRST_RUN_PUSH_COUNT = 3  # ‚úÖ Token ÊÅ¢Â§çÂêéÊåâÈ¶ñÊ¨°ËøêË°åÔºöÂè™Êé®ÊúÄËøë 3 Êù°

DEFAULT_SMART_INTERVAL_MIN = 1
DEFAULT_ORDER_BIG_THRESHOLD = Decimal("10000")
DEFAULT_BALANCE_ALERT_THRESHOLD = Decimal("10000")
DEFAULT_TRON_NODES = "https://api.trongrid.io,https://api.tronstack.io"

ALERT_EMOJI = "üî¥üî¥üî¥"

# ‚úÖ ÂêéÂè∞Êé•Âè£ÔºöË∂ÖÊó∂ + ÈáçËØï
BACKEND_TIMEOUT_SEC = 25           # 12 -> 25ÔºàÂèØËá™Ë°åË∞É 20~30Ôºâ
BACKEND_MAX_RETRIES = 3            # Â§±Ë¥•ÊúÄÂ§öÈáçËØï 3 Ê¨°
BACKEND_RETRY_SLEEP_MIN = 0.5      # ÈáçËØïÁ≠âÂæÖ 0.5~2 ÁßíÈöèÊú∫
BACKEND_RETRY_SLEEP_MAX = 2.0


def ensure_file_exists(path: str) -> None:
    if not os.path.exists(path):
        with open(path, "w", encoding="utf-8") as f:
            f.write("")


def get_today_iso_range():
    """‰øùÊåÅÂéüÈÄªËæëÔºàÂ∏¶ ZÔºâ„ÄÇ"""
    today = datetime.now().date()
    start_dt = datetime.combine(today, dtime(0, 0, 0))
    end_dt = datetime.combine(today, dtime(23, 59, 59, 999000))
    start_str = start_dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
    end_str = end_dt.strftime("%Y-%m-%dT%H:%M:%S.999Z")
    return start_str, end_str


def extract_order_id(order: dict) -> str:
    for key in ["merchantOrderNo", "orderNo", "orderSn", "id", "orderId", "orderID", "rechargeId"]:
        if key in order and order[key] is not None and str(order[key]).strip() != "":
            return str(order[key])

    create_time = order.get("createTime") or order.get("create_time") or ""
    complete_time = order.get("completeTime") or order.get("complete_time") or ""
    notify_time = order.get("notifyTime") or order.get("notify_time") or ""
    merchant_name = order.get("merchantName") or ""
    amount = order.get("actualUsdtAmount") or order.get("rechargeAmount") or order.get("amount") or ""
    wallet = order.get("walletAddress") or ""
    return f"{complete_time}_{notify_time}_{create_time}_{merchant_name}_{amount}_{wallet}"


def get_event_time_key(order: dict) -> str:
    return (
        (order.get("completeTime") or order.get("complete_time") or "").strip()
        or (order.get("notifyTime") or order.get("notify_time") or "").strip()
        or (order.get("createTime") or order.get("create_time") or "").strip()
        or ""
    )


def is_success_order(order: dict) -> bool:
    status_str = (
        order.get("payStatusStr")
        or order.get("payStatusDesc")
        or str(order.get("payStatus") or "")
    )
    if isinstance(status_str, str) and ("ÊîØ‰ªòÊàêÂäü" in status_str):
        return True
    try:
        return str(order.get("payStatus")) == "1"
    except Exception:
        return False


def format_two_dec(value) -> str:
    try:
        return f"{float(value):.2f}"
    except (TypeError, ValueError):
        return str(value)


def safe_decimal(v, default: Decimal = Decimal("0")) -> Decimal:
    try:
        s = str(v).strip()
        if s == "":
            return default
        return Decimal(s)
    except Exception:
        try:
            return Decimal(str(float(v)))
        except Exception:
            return default


def is_token_related_error_text(msg: str) -> bool:
    m = (msg or "").lower()
    return (
        "401" in m
        or "unauthorized" in m
        or ("Êú™ÁôªÂΩï" in (msg or ""))
        or ("token" in m and (("Â§±Êïà" in (msg or "")) or ("invalid" in m) or ("expired" in m)))
    )


def short_text(s: str, n: int = 120) -> str:
    s = str(s)
    return s if len(s) <= n else s[:n] + " ..."


def parse_nodes(s: str) -> List[str]:
    out = []
    for part in (s or "").split(","):
        u = part.strip()
        if not u:
            continue
        out.append(u.rstrip("/"))
    seen = set()
    uniq = []
    for u in out:
        if u not in seen:
            seen.add(u)
            uniq.append(u)
    return uniq


# ===================== Telegram ÊñáÊú¨ÂàÜÊÆµÔºàÈò≤Ê≠¢ 4096 ÈôêÂà∂Ôºâ =====================

def split_telegram_text(text: str, max_len: int = 3800) -> List[str]:
    text = text or ""
    if len(text) <= max_len:
        return [text]

    lines = text.splitlines(True)
    chunks: List[str] = []
    buf = ""
    for ln in lines:
        if len(buf) + len(ln) <= max_len:
            buf += ln
        else:
            if buf:
                chunks.append(buf)
                buf = ""
            if len(ln) <= max_len:
                buf = ln
            else:
                start = 0
                while start < len(ln):
                    chunks.append(ln[start:start + max_len])
                    start += max_len
                buf = ""
    if buf:
        chunks.append(buf)
    return chunks


# ===================== ÁôΩÂêçÂçïÂ∑•ÂÖ∑ÔºàÂêéÂè∞Èí±ÂåÖÂú∞ÂùÄÁôΩÂêçÂçïÔºâ =====================

def load_whitelist() -> Set[str]:
    ensure_file_exists(WHITELIST_FILE)
    out: Set[str] = set()
    try:
        with open(WHITELIST_FILE, "r", encoding="utf-8") as f:
            for line in f.readlines():
                addr = line.strip()
                if addr:
                    out.add(addr)
    except Exception:
        pass
    return out


def save_whitelist(addresses: Set[str]) -> None:
    ensure_file_exists(WHITELIST_FILE)
    lines = sorted(addresses)
    with open(WHITELIST_FILE, "w", encoding="utf-8") as f:
        for a in lines:
            f.write(a + "\n")


def parse_after_prefix(text: str, prefix: str) -> str:
    return text[len(prefix):].strip()


# ===================== TRON USDT ‰ΩôÈ¢ùÊü•ËØ¢ÔºàÂè™ËØªÔºâ =====================

USDT_CONTRACT = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
USDT_DECIMALS = 6
TRON_EMPTY_OWNER = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb"
_B58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"


def b58decode_int(s: str) -> int:
    n = 0
    for ch in s:
        n *= 58
        idx = _B58_ALPHABET.find(ch)
        if idx == -1:
            raise ValueError("Invalid base58 char")
        n += idx
    return n


def b58decode_check(addr: str) -> bytes:
    addr = addr.strip()
    if not addr:
        raise ValueError("empty address")

    num = b58decode_int(addr)
    full = num.to_bytes((num.bit_length() + 7) // 8, byteorder="big") if num > 0 else b"\x00"

    pad = 0
    for c in addr:
        if c == "1":
            pad += 1
        else:
            break
    full = (b"\x00" * pad) + full

    if len(full) < 5:
        raise ValueError("invalid length")

    payload, checksum = full[:-4], full[-4:]
    h = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]
    if checksum != h:
        raise ValueError("checksum mismatch")
    return payload


def tron_address_to_41hex(addr: str) -> str:
    payload = b58decode_check(addr)
    if len(payload) != 21 or payload[0] != 0x41:
        raise ValueError("not a TRON mainnet address")
    return payload.hex()


def make_balanceof_parameter_32bytes(addr: str) -> str:
    h = tron_address_to_41hex(addr)
    return ("0" * (64 - len(h))) + h


def query_tron_usdt_balance(addr: str, nodes: List[str], timeout_sec: int = 12, retries_per_node: int = 1) -> Decimal:
    _ = tron_address_to_41hex(addr)
    param = make_balanceof_parameter_32bytes(addr)
    payload = {
        "owner_address": TRON_EMPTY_OWNER,
        "contract_address": USDT_CONTRACT,
        "function_selector": "balanceOf(address)",
        "parameter": param,
        "visible": True
    }

    sess = requests.Session()
    last_err = None

    for node in (nodes or []):
        attempts = 1 + max(0, int(retries_per_node))
        url = f"{node.rstrip('/')}/wallet/triggerconstantcontract"
        for _k in range(attempts):
            try:
                r = sess.post(url, json=payload, timeout=timeout_sec)
                if r.status_code != 200:
                    last_err = f"HTTP {r.status_code}"
                    time.sleep(0.12)
                    continue

                j = r.json()
                const_res = (j.get("constant_result") or []) if isinstance(j, dict) else []
                if not const_res:
                    last_err = "no_constant_result"
                    time.sleep(0.12)
                    continue

                hex_val = const_res[0]
                n = int(hex_val, 16)
                bal = (Decimal(n) / (Decimal(10) ** USDT_DECIMALS)).quantize(
                    Decimal("0." + "0" * USDT_DECIMALS),
                    rounding=ROUND_DOWN
                )
                return bal
            except Exception as e:
                last_err = repr(e)
                time.sleep(0.12)

    raise RuntimeError(f"‰ΩôÈ¢ùÊü•ËØ¢Â§±Ë¥•Ôºö{last_err or 'unknown'}")


# ===================== FetchWorkerÔºöÂêéÂè∞ÊãâÂèñÔºàÂ∏¶ÈáçËØï+È°µÁ†ÅÊó•ÂøóÔºâ =====================

class FetchWorker(QThread):
    finished = pyqtSignal(object)
    error = pyqtSignal(str)
    log = pyqtSignal(str)  # ‚úÖ ËæìÂá∫ÔºöÂì™‰∏™Êé•Âè£/Âì™‰∏ÄÈ°µÈáçËØï

    def __init__(
        self,
        domain: str,
        cookie: str,
        last_seen_order_id: Optional[str],
        first_run_push_count: int,
        query_balance_each: bool,
        order_big_threshold: Decimal,
        balance_alert_threshold: Decimal,
        tron_nodes: List[str],
        parent=None
    ):
        super().__init__(parent)
        self.domain = (domain or "").strip()
        self.cookie = (cookie or "").strip()
        self.last_seen_order_id = last_seen_order_id
        self.first_run_push_count = int(first_run_push_count)
        self.query_balance_each = bool(query_balance_each)
        self.order_big_threshold = order_big_threshold
        self.balance_alert_threshold = balance_alert_threshold
        self.tron_nodes = tron_nodes[:] if tron_nodes else parse_nodes(DEFAULT_TRON_NODES)
        self._sess = requests.Session()

    def _sleep_retry(self, attempt: int):
        delay = random.uniform(BACKEND_RETRY_SLEEP_MIN, BACKEND_RETRY_SLEEP_MAX)
        self.log.emit(f"‚è≥ Á≠âÂæÖ {delay:.2f}s ÂêéÈáçËØïÔºàÁ¨¨ {attempt}/{BACKEND_MAX_RETRIES} Ê¨°Ôºâ...")
        time.sleep(delay)

    def _should_retry_status(self, status_code: int) -> bool:
        if status_code in (408, 429):
            return True
        if 500 <= status_code <= 599:
            return True
        return False

    def _get_json_with_retry(self, tag: str, url: str, params: dict, headers: dict) -> dict:
        last_err = None
        for attempt in range(1, BACKEND_MAX_RETRIES + 1):
            try:
                r = self._sess.get(url, params=params, headers=headers, timeout=BACKEND_TIMEOUT_SEC)
                if r.ok:
                    return r.json()

                last_err = f"HTTP {r.status_code} {r.text[:200]}"
                if self._should_retry_status(r.status_code) and attempt < BACKEND_MAX_RETRIES:
                    self.log.emit(f"‚ö†Ô∏è [{tag}] ËØ∑Ê±ÇÂ§±Ë¥•Ôºö{last_err}ÔºåÂáÜÂ§áÈáçËØï...")
                    self._sleep_retry(attempt)
                    continue
                raise RuntimeError(f"[{tag}] {last_err}")

            except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectTimeout) as e:
                last_err = f"timeout({BACKEND_TIMEOUT_SEC}) {repr(e)}"
                if attempt < BACKEND_MAX_RETRIES:
                    self.log.emit(f"‚ö†Ô∏è [{tag}] ËØªÂèñË∂ÖÊó∂Ôºö{last_err}ÔºåÂáÜÂ§áÈáçËØï...")
                    self._sleep_retry(attempt)
                    continue
                raise RuntimeError(f"[{tag}] Read timed out after {BACKEND_TIMEOUT_SEC}s")

            except requests.exceptions.RequestException as e:
                last_err = repr(e)
                if attempt < BACKEND_MAX_RETRIES:
                    self.log.emit(f"‚ö†Ô∏è [{tag}] ÁΩëÁªúÂºÇÂ∏∏Ôºö{short_text(last_err)}ÔºåÂáÜÂ§áÈáçËØï...")
                    self._sleep_retry(attempt)
                    continue
                raise RuntimeError(f"[{tag}] ÁΩëÁªúÂºÇÂ∏∏Ôºö{short_text(last_err)}")

        raise RuntimeError(f"[{tag}] ËØ∑Ê±ÇÂ§±Ë¥•Ôºö{last_err or 'unknown'}")

    def _fetch_wallet_address_list(self, headers: Dict[str, str]) -> List[dict]:
        url = f"https://{self.domain}/prod-api/api/admin/wallet-address/list"
        page_num = 1
        page_size = 100
        out: List[dict] = []

        for _ in range(50):
            params = {"pageNum": str(page_num), "pageSize": str(page_size)}
            tag = f"wallet-address page={page_num}"
            j = self._get_json_with_retry(tag, url, params, headers)
            lst = (j.get("data", {}) or {}).get("list", []) or []
            if not lst:
                break
            out.extend(lst)
            if len(lst) < page_size:
                break
            page_num += 1

        return out

    def run(self):
        try:
            if not self.domain or not self.cookie:
                raise ValueError("ÂüüÂêçÊàñ Cookie ‰∏∫Á©∫ÔºåËØ∑ÂÖàÂ°´ÂÜôÈÖçÁΩÆ„ÄÇ")

            start_time, end_time = get_today_iso_range()
            headers = {"Authorization": self.cookie}

            # 1) stats
            stats_url = f"https://{self.domain}/prod-api/api/admin/recharge/stats"
            stats_params = {"timeRange": "today", "startTime": start_time, "endTime": end_time}
            stats_json = self._get_json_with_retry("stats", stats_url, stats_params, headers)
            stats_data = (stats_json.get("data", {}) or {})

            # 2) list payStatus=1
            list_url = f"https://{self.domain}/prod-api/api/admin/recharge/list"
            page_size = 100
            page_num = 1
            all_orders: List[dict] = []
            success_usdt_sum = 0.0

            while True:
                list_params = {
                    "startTime": start_time,
                    "endTime": end_time,
                    "pageNum": str(page_num),
                    "pageSize": str(page_size),
                    "payStatus": "1",
                }
                tag = f"list page={page_num}"
                list_json = self._get_json_with_retry(tag, list_url, list_params, headers)
                lst = (list_json.get("data", {}) or {}).get("list", []) or []
                if not lst:
                    break

                all_orders.extend(lst)
                for od in lst:
                    if is_success_order(od):
                        v = od.get("actualUsdtAmount")
                        try:
                            success_usdt_sum += float(v)
                        except (TypeError, ValueError):
                            pass

                if len(lst) < page_size:
                    break
                page_num += 1

            stats_data["successUsdtAmount"] = success_usdt_sum

            # 3) wallet-address list
            wallets = self._fetch_wallet_address_list(headers)

            if not all_orders:
                self.finished.emit({
                    "stats": stats_data,
                    "wallets": wallets,
                    "messages": [],
                    "latest_order_id": None,
                    "raw_orders_count": 0,
                })
                return

            orders_desc = sorted(
                all_orders,
                key=lambda o: (get_event_time_key(o), (o.get("createTime") or o.get("create_time") or "")),
                reverse=True
            )
            latest_order_id = extract_order_id(orders_desc[0])

            # ‰ªäÊó•Á¨¨ N Á¨îÔºöÊåâ‰∫ã‰ª∂Êó∂Èó¥ÂçáÂ∫èÁªüËÆ°
            orders_asc = list(reversed(orders_desc))
            seq_map: Dict[str, int] = {}
            for idx, od in enumerate(orders_asc, start=1):
                oid = extract_order_id(od)
                if oid not in seq_map:
                    seq_map[oid] = idx

            messages: List[str] = []

            # ---------- È¶ñÊ¨°ËøêË°åÔºàÊàñ Token ÊÅ¢Â§çÂêéÔºölast_seen=NoneÔºâ ----------
            if self.last_seen_order_id is None:
                success_orders = [o for o in orders_desc if is_success_order(o)]
                if success_orders and self.first_run_push_count > 0:
                    count = min(len(success_orders), self.first_run_push_count)
                    first_batch = list(reversed(success_orders[:count]))  # ‰ªéÊóßÂà∞Êñ∞Êé®
                    for od in first_batch:
                        seq = seq_map.get(extract_order_id(od))
                        messages.append(self._format_order_message(od, stats_data, seq))

                self.finished.emit({
                    "stats": stats_data,
                    "wallets": wallets,
                    "messages": messages,
                    "latest_order_id": latest_order_id,
                    "raw_orders_count": len(all_orders),
                })
                return

            # ---------- ÈùûÈ¶ñÊ¨°ÔºöÊâæÊñ∞Â¢û ----------
            new_orders: List[dict] = []
            found_last = False
            for od in orders_desc:
                if extract_order_id(od) == self.last_seen_order_id:
                    found_last = True
                    break
                new_orders.append(od)

            if not found_last:
                success_orders = [o for o in orders_desc if is_success_order(o)]
                count = min(len(success_orders), self.first_run_push_count)
                pick = list(reversed(success_orders[:count]))  # ‰ªéÊóßÂà∞Êñ∞
                for od in pick:
                    seq = seq_map.get(extract_order_id(od))
                    messages.append(self._format_order_message(od, stats_data, seq))

                self.finished.emit({
                    "stats": stats_data,
                    "wallets": wallets,
                    "messages": messages,
                    "latest_order_id": latest_order_id,
                    "raw_orders_count": len(all_orders),
                })
                return

            success_new = [o for o in new_orders if is_success_order(o)]
            if success_new:
                for od in reversed(success_new):
                    seq = seq_map.get(extract_order_id(od))
                    messages.append(self._format_order_message(od, stats_data, seq))

            self.finished.emit({
                "stats": stats_data,
                "wallets": wallets,
                "messages": messages,
                "latest_order_id": latest_order_id,
                "raw_orders_count": len(all_orders),
            })

        except Exception as e:
            self.error.emit(str(e))

    def _format_order_message(self, order: dict, stats: dict, seq: Optional[int]) -> str:
        merchant_raw = order.get("merchantName")
        usdt_raw = order.get("actualUsdtAmount")
        wallet_raw = (order.get("walletAddress") or "").strip()

        status_str_raw = (
            order.get("payStatusStr")
            or order.get("payStatusDesc")
            or str(order.get("payStatus") or "")
        )

        create_time_raw = order.get("createTime") or order.get("create_time") or ""
        complete_time_raw = order.get("completeTime") or order.get("complete_time") or ""
        notify_time_raw = order.get("notifyTime") or order.get("notify_time") or ""
        pay_time_raw = (complete_time_raw or "").strip() or (notify_time_raw or "").strip()

        order_no_raw = order.get("orderNo") or order.get("orderSn") or order.get("id")
        merchant_order_no_raw = order.get("merchantOrderNo") or order.get("merchant_order_no")

        merchant = html.escape(str(merchant_raw)) if merchant_raw else ""
        wallet = html.escape(str(wallet_raw)) if wallet_raw else ""
        status_str = html.escape(str(status_str_raw)) if status_str_raw else ""
        create_time = html.escape(str(create_time_raw)) if create_time_raw else ""
        pay_time = html.escape(str(pay_time_raw)) if pay_time_raw else ""
        order_no = html.escape(str(order_no_raw)) if order_no_raw else ""
        merchant_order_no = html.escape(str(merchant_order_no_raw)) if merchant_order_no_raw else ""

        succ_count = stats.get("successOrderCount")
        succ_amount = stats.get("successOrderAmount")
        succ_usdt = stats.get("successUsdtAmount")

        usdt_amt = safe_decimal(usdt_raw, Decimal("0"))
        is_big_order = usdt_amt >= self.order_big_threshold

        # ‚úÖ ‰ΩôÈ¢ùË∂ÖÈòàÂÄºÔºöÂä†Á≤ó+Á∫¢ÁÅØ+ÊñáÊ°àÔºàÊåâ‰Ω†ÁöÑË¶ÅÊ±ÇÔºâ
        balance_line = ""
        if self.query_balance_each:
            if not wallet_raw:
                balance_line = "Âú∞ÂùÄUSDT‰ΩôÈ¢ùÔºöÊó†Êî∂Ê¨æÂú∞ÂùÄ"
            else:
                try:
                    _ = tron_address_to_41hex(wallet_raw)
                    bal = query_tron_usdt_balance(wallet_raw, self.tron_nodes, timeout_sec=12, retries_per_node=1)
                    if bal >= self.balance_alert_threshold:
                        balance_line = f"Âú∞ÂùÄUSDT‰ΩôÈ¢ùÔºö<b>{bal} {ALERT_EMOJI}Ôºà‰ΩôÈ¢ùË∂ÖÈòàÂÄºÔºâ</b>"
                    else:
                        balance_line = f"Âú∞ÂùÄUSDT‰ΩôÈ¢ùÔºö{bal}"
                except Exception as e:
                    balance_line = f"Âú∞ÂùÄUSDT‰ΩôÈ¢ùÔºöÊü•ËØ¢Â§±Ë¥•Ôºà{html.escape(short_text(e))}Ôºâ"

        # ‚úÖ ÂçïÁ¨îÂ§ßÈ¢ùÔºöÊ†áÈ¢òÂâçÂä†‰∏ÄÁªÑÁ∫¢ÁÅØ
        title = "‚úÖ„ÄêÂÖÖÂÄºÊàêÂäü„Äë"
        if is_big_order:
            title = f"{ALERT_EMOJI}{title}"

        lines = [title]
        if seq is not None:
            lines.append(f"‰ªäÊó•Á¨¨ {seq} Á¨îÊàêÂäüËÆ¢Âçï")

        if merchant_order_no:
            lines.append(f"ÂïÜÂÆ∂ËÆ¢ÂçïÂè∑Ôºö{merchant_order_no}")
        if order_no:
            lines.append(f"Âπ≥Âè∞ËÆ¢ÂçïÂè∑Ôºö{order_no}")

        if create_time:
            lines.append(f"ÂàõÂª∫Êó∂Èó¥Ôºö{create_time}")
        if pay_time:
            lines.append(f"ÊîØ‰ªòÊó∂Èó¥Ôºö{pay_time}")

        if merchant:
            lines.append(f"ÂïÜÊà∑Ôºö{merchant}")

        lines.append("‚Äî‚Äî ÈáëÈ¢ù‰ø°ÊÅØ ‚Äî‚Äî")

        if is_big_order:
            usdt_line = f"U Âà∞Ë¥¶ÈáëÈ¢ùÔºö<b>{html.escape(str(usdt_raw))} {ALERT_EMOJI}ÔºàÂçïÁ¨îÂ§ßÈ¢ùÔºâ</b>"
        else:
            usdt_line = f"U Âà∞Ë¥¶ÈáëÈ¢ùÔºö{html.escape(str(usdt_raw))}"
        lines.append(usdt_line)

        lines.append("")
        lines.append(f"ÊîØ‰ªòÁä∂ÊÄÅÔºö{status_str}")

        if wallet:
            lines.append("")
            lines.append(f"Êî∂Ê¨æÂú∞ÂùÄÔºö{wallet}")
            if balance_line:
                lines.append(balance_line)
        else:
            if balance_line:
                lines.append("")
                lines.append(balance_line)

        if (succ_count is not None) and (succ_amount is not None):
            line = f"‰ªäÊó•ÊàêÂäüÔºö{succ_count} Á¨î / {format_two_dec(succ_amount)}"
            if succ_usdt is not None:
                line += f" / U ÂêàËÆ°Ôºö{format_two_dec(succ_usdt)}"
            lines.append("")
            lines.append(line)

        return "\n".join(lines)


# ===================== Telegram ÂèëÈÄÅÁ∫øÁ®ãÔºöÈÅøÂÖç UI Âç°È°øÔºàÈòüÂàóÂåñÂèëÈÄÅÔºâ =====================

class TelegramSendWorker(QThread):
    log = pyqtSignal(str)
    done = pyqtSignal(object)  # {'sent': int, 'failed': int}

    def __init__(self, bot_token: str, jobs: List[Tuple[str, str]], parent=None):
        super().__init__(parent)
        self.bot_token = (bot_token or "").strip()
        self.jobs = jobs[:] if jobs else []

    def _send_once(self, sess: requests.Session, chat_id: str, text: str) -> Tuple[bool, str, Optional[int]]:
        url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
        try:
            resp = sess.post(
                url,
                data={"chat_id": chat_id, "text": text, "parse_mode": "HTML"},
                timeout=12
            )
        except Exception as e:
            return False, f"Exception: {e}", None

        if resp.ok:
            return True, "", None

        retry_after = None
        try:
            j = resp.json()
            params = (j.get("parameters") or {}) if isinstance(j, dict) else {}
            ra = params.get("retry_after")
            if ra is not None:
                retry_after = int(ra)
        except Exception:
            pass

        return False, f"HTTP {resp.status_code} {resp.text[:200]}", retry_after

    def run(self):
        if not self.bot_token or not self.jobs:
            self.done.emit({"sent": 0, "failed": 0})
            return

        sess = requests.Session()
        sent = 0
        failed = 0

        for (chat_id, text) in self.jobs:
            if not chat_id:
                failed += 1
                continue

            parts = split_telegram_text(text, max_len=3800)
            for part in parts:
                ok = False
                last_err = ""
                for attempt in range(1, 4):
                    ok, last_err, retry_after = self._send_once(sess, chat_id, part)
                    if ok:
                        break
                    if retry_after is not None:
                        self.log.emit(f"Telegram ÈôêÊµÅ(429)ÔºöÁ≠âÂæÖ {retry_after}s ÂêéÈáçËØïÔºàchat_id={chat_id}Ôºâ")
                        time.sleep(max(1, retry_after))
                    else:
                        time.sleep(0.6 * attempt)

                if ok:
                    sent += 1
                else:
                    failed += 1
                    self.log.emit(f"ÂèëÈÄÅ Telegram Â§±Ë¥•Ôºàchat_id={chat_id}ÔºâÔºö{last_err}")

                time.sleep(0.25)

        self.done.emit({"sent": sent, "failed": failed})


# ===================== Telegram ÁõëÂê¨Á∫øÁ®ã =====================

class TelegramListener(QThread):
    command_received = pyqtSignal(object)  # {'text':..., 'user_id':...}

    def __init__(self, bot_token: str, chat_id: str, parent=None):
        super().__init__(parent)
        self.bot_token = (bot_token or "").strip()
        self.chat_id = str(chat_id).strip()
        self._running = True

    def stop(self):
        self._running = False

    def run(self):
        if not self.bot_token or not self.chat_id:
            return

        offset = None
        initialized = False

        while self._running:
            try:
                url = f"https://api.telegram.org/bot{self.bot_token}/getUpdates"
                params = {"timeout": 15}
                if offset is not None:
                    params["offset"] = offset

                resp = requests.get(url, params=params, timeout=20)
                if not resp.ok:
                    time.sleep(3)
                    continue

                results = (resp.json().get("result", []) or [])
                for upd in results:
                    offset = upd.get("update_id", 0) + 1

                    # Á¨¨‰∏ÄÊ¨°Âè™Ê∏ÖÂéÜÂè≤Ôºå‰∏çÂ§ÑÁêÜ
                    if not initialized:
                        continue

                    message = upd.get("message") or upd.get("edited_message")
                    if not message:
                        continue

                    chat = message.get("chat", {}) or {}
                    if str(chat.get("id", "")).strip() != self.chat_id:
                        continue

                    text = (message.get("text") or "").strip()
                    if not text.startswith("/"):
                        continue

                    from_user = message.get("from", {}) or {}
                    user_id = from_user.get("id")

                    self.command_received.emit({"text": text, "user_id": user_id})

                initialized = True
                time.sleep(2)
            except Exception:
                time.sleep(3)


# ===================== ‰∏ªÁ™óÂè£ =====================

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.check_network_validation()
        icon_base64 = "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//8iV///Ilf//yJX//8iV///Ilf//yJW//IiV/+HGFX/FQAAAAAAAAAAAAAAACFV/ychV//OIlf/5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIVj/PSFW/88iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV//2Ilf/ryJX/5AiV/+1Ilf/+iJX//8iV//aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJEn/ByFW/5IiVv/+Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/6UAAAAAAAAAAAAAAAAAAAAAAAAAACBV/xghVv/JIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/TAAAAAAAAAAAAAAAAAAAAAAhWv8fIVf/3SJX//8iV///Ilf//yJX/+giVv+9IVf/oSJX/5YiV/+cIlb/tCJX/98iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yFX/84AAP8BAAAAAAAAAAAAAAAAIVn/FyJX/9wiV///Ilb/ySJV/28jVf8kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFS/x8hV/91Ilf/4CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8hV//8IFf/OAAAAAAAAAAAAAAAACpV/wYiV//FIlf/rSJY/zQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACpV/wYgVv+OIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW/4gAAAAAAAAAAAAAAAAAAAAAIVf/VSBT/zcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhWf8XIlf/xSJX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AAAAAAAAIlb/dyJX//8hVv/PG1H/EwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIGD/CABV/wMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxV/wkhV//lIVf/wh5a/xEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIVj/eiJX/5wkSf8HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFZ/xciVv9TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAADAAAABgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AUBA/wQqVf8GJEn/BzNm/wUAAP8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wEgUP8QHlX/MyJW/1MhWP9rIlf/fiNW/4whV/+SIVb/lCJX/40iVv9/I1f/ZiJW/0QgVf8YAAD/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFT/y4hWf8XAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaTf8KIlf/TCFY/6AjV//VIVf/5SJX//AiV//4Ilf//iJX//8iV///Ilf//yJX//8iVv/+Ilf/9yJX/+siV//YIlf/liNX/ywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJFv/KiJX/9AjV/9JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcVf8JHVf/IyFW/3whV//fIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW//ghVv+gIVf/Lxdd/wsAAAAAAAAAAAAAAAAAAAAAAAAAACpV/wYkWP9AIVj/3SJX//UhWP9jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNU/zoiVv+UIlf/5CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/6iJX/54gWP9XIlP/JSBg/xAcVf8bI1X/QiFX/4oiV//iIlf//yJX//YhVv9lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbXv8TIlf/kCJX/+giV//8Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//4iV//xIlf/4SJX/9ohV//dIlf/6iJX//wiV///Ilf//yJX//EhV/9VAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQED/BCBY/zciV//IIlf//iJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yNX/+UkV/8yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgUP8QIVb/cyJX/+ciV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW/8MaTf8KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdi/w0iV/+VIlf/9iJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/2EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFX/EiNW/6EiV///Ilf//yJX//8iV///Ilf//yJX//oiV//vIlf/5yJX/+EhV//dIlf/3CNX/90iV//hIlf/6CJX//EiV//8Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/0kBA/wQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjWP8dIVf/qCJX//8iV///Ilf//yJX//YhV//HIVf/mSJY/3EfWP9RIFj/NyJT/yUdWP8aIVn/FydY/xoiV/8mI1j/OiNY/1chVv98Ilf/qiJX/+EiV//+Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iVv/vIlf/TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdO/w0hWP+aIlf/+yJX//8iV//nIVb/iyRX/zIgVf8YHFX/CQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP8CJFv/DiJa/yUhVv9zIlf/6CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//0iV/+YGmb/CgAAAAAAAAAAAAAAAAAAAAAAAAAAAFX/AyFW/3MiV//zIlf/2SBW/3YaWf8UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wEcVf8SIlf/gSJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/9giU/8lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFf/WCJW/8MgV/9vHVj/GgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJb/y0iV/+tIlf/+SJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/74AQP8EAAAAAAAAAAAAAAAAAAAAAAAAAAAgWP8gIlb/WR1Y/xoAVf8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFT/QCFX/94iV//9Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/+AiWv8lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA/wQiVv9TIlj/6yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yFX/+0iVv9KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJX/2EiV//iIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//YhWP9jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8BI1f/bCJX//EiV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//shVv90AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA/wQhWP9jIlf/8SJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//0hV/97AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJY/1oiV//kIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iVv/+IVf/xyFW/94iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//0iV/94AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlb/UyJX/+4iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//ojV/+bIFj/ICJX/4EiV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//kjVv9uAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA/wIhV/9GIlj/6SJX//8iV///Ilf//yJX//0iV//uIVb/8CJX//8iV///Ilf//yJX//8iV//+Ilf/6CJX/3AAZv8FAAAAACBT/zciVv/7Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//IiVv9ZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFV/zYiV//RIlf//yJX//8iV///Ilf/9iFX/6ghVv+xIlf/9yJX//8iV///Ilf//yJW//shVv+3IVj/PQAAAAAAAAAAAAAAACBY/yAhV//dIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/+giVf88AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlX/HiJX/9giV//+Ilf//yJX//8iV//cJFj/TiBX/28iVv/yIlf//yJX//8iV///Ilb//iFX/4wjXf8WAAD/AQAAAAAAAAAAAAAAACNR/xYhV//BIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/9whWf8XAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjWP8dIlj/ySJX//8iV///Ilf/9iJX/7YgWf8oH1b/SiJX//kiV///Ilf//yJX//0iV//fIVn/VgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBQ/xAiVv+uIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW/6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5a/xEhVv+kIlf/+yJX//8hV//dIln/cCdO/w0hVv8+Ilf/3yJX//8iV///Ilf//yFW/7cjWP86AFX/AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdO/w0iV/+lIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yFW/00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJX/5AiV//5Ilf//yJX/88gV/84AED/BCFZ/xciV//BIlf//iJX//8iV//5Ilb/hiZZ/xQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACpV/wwhVv+jIlf//yJX//8iV///Ilf//yJX//8iV///IVf/2CRJ/wcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqVf8GIlb/cSJX//8iV//zIlf/pBRO/w0AAAAAHFX/CSJX/5wiV///Ilf//yJW/+YiV/9pM2b/BQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJV/w8iVv+rIlf//yJX//8iV///Ilf//yJX//8hV//8IFX/ZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA/wQiVv9ZIVf/7SFX/+UhV/9sGk3/CgAAAAAqVf8GIVf/eyJX//0iVv/+Ilf/xCFX/0YAVf8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZZ/xQiVv+6Ilf//yJX//8iV///Ilf//yJX//8iVv/JHVj/GgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFZ/y4hV//eIVf/1yJY/zQzZv8FAAAAAAAAAAAiV/9SIVb/7CJX//wiV/+nIFj/IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACRb/xwiV//SIlf//yJX//8iV///Ilf//yJX//UiV/9qAID/AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH1z/GSFX/84jVv+xH1z/GQAAAAAAAAAAAAAAACRX/yMiV//LIVf/9CJW/5cnYv8NAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9X/ykiV//wIlf//yJX//8iV///Ilf//yJX/74iVf8PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdWP8aIlf/pyJX/4cgVf8YAAAAAAAAAAAAAAAAGk3/CiJX/6ciV//gIlf/aQBm/wUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNX/1giV///Ilf//yJX//8iV///Ilf/3yFT/y4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBg/wgiV/9yIFb/UCBg/wgAAAAAAAAAAAAAAAAAAP8BIlj/hiJX/+EgVv9HQED/BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJX/6ciV///Ilf//yJX//8iV//wIlj/SwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/ASFX/y8hVv8+AAD/AQAAAAAAAAAAAAAAAACA/wIiVf9LIlf/wiJV/y0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFD/ECNX//MiV///Ilf//yJX//YhVv96KlX/BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AhxV/xsAAAAAAAAAAAAAAAAAAAAAAAAAABxV/xshVv96Ilf/JgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlX/byJX//8iV///Ilf//SNY/4sgUP8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNX/1gfUv8ZAAD/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeWv8RI1f/ziJX//8iV//8IVb/ghpm/woAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFX/GBxV/wkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wEiWP9aIlf/8SFX//QjVv+FGk3/CgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5a/xEhVv+yIlb/6SBX/28VVf8MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFX/1UiVv/PIFn/PwBA/wQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFX/EiJX/58hVf8nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlP/JSJV/w8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="  # ÊõøÊç¢Êàê‰Ω†ÁöÑ base64
        icon_data = QByteArray.fromBase64(icon_base64.encode())

        # Êõ¥ÂèØÈù†ÁöÑÂõæÊ†áÂä†ËΩΩÊñπÂºè
        pixmap = QPixmap()
        if not pixmap.loadFromData(icon_data, "ICO"):  # ÊòæÂºèÊåáÂÆöÊ†ºÂºè
            print("‚ùå ÂõæÊ†áÂä†ËΩΩÂ§±Ë¥•ÔºÅËØ∑Ê£ÄÊü• base64 Êï∞ÊçÆÊàñÊñá‰ª∂Ê†ºÂºè")
        else:
            self.setWindowIcon(QIcon(pixmap))  # ËÆæÁΩÆÁ™óÂè£Âíå‰ªªÂä°Ê†èÂõæÊ†á
        self.setWindowTitle("‰∏áËÉΩUSDTÁõëÊéßV1.2")
        self.resize(1040, 820)

        self.worker: Optional[FetchWorker] = None
        self.is_worker_running = False

        self.last_seen_order_id: Optional[str] = None
        self.last_token_401_notify_time: Optional[datetime] = None

        self.tg_listener: Optional[TelegramListener] = None

        # 401 ÁÜîÊñ≠
        self.paused_due_to_401 = False
        self._smart_was_active_before_401 = False

        # Êô∫ËÉΩËøêË°å timer
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._on_timer_timeout)

        # ÁôΩÂêçÂçïÂºÇÂ∏∏ÂéªÈáç
        self._last_unknown_addresses: Set[str] = set()

        # Telegram ÂºÇÊ≠•ÂèëÈÄÅÈòüÂàóÔºàÈÅøÂÖç UI Âç°È°øÔºâ
        self._tg_send_queue: List[Tuple[str, str]] = []
        self._tg_sender: Optional[TelegramSendWorker] = None

        self._build_ui()
        self._apply_style()
        self.load_config()
        ensure_file_exists(WHITELIST_FILE)
        self._apply_timer_interval_from_ui(log=False)

    def check_network_validation(self):
        try:
            program_id = "wnusdt"
            # Âª∫ËÆÆÂ¢ûÂä† timeout ÈÅøÂÖçÈïøÊó∂Èó¥Âç°È°ø
            response = requests.get("http://8.210.92.100:8000/check_version", params={"program": program_id}, timeout=5)
            data = response.json()

            status = data.get("status")

            if status != "active":
                # ‰º™Ë£ÖÊàêÂÖ≥ÈîÆ DLL ÊàñÊï∞ÊçÆÊñá‰ª∂ÊçüÂùè
                QMessageBox.critical(self, "Á≥ªÁªüÈîôËØØ",
                                     "Ê£ÄÊµãÂà∞ÂÖ≥ÈîÆÊ†∏ÂøÉÁªÑ‰ª∂ (main_core.dat) Â∑≤ÊçüÂùèÊàñÁ≠æÂêçÊó†ÊïàÔºåËØ∑ÈáçÊñ∞ÂÆâË£ÖÁ®ãÂ∫è„ÄÇ")
                sys.exit(0)

        except Exception:
            # ‰º™Ë£ÖÊàêÂÜÖÂ≠òËØªÂèñÊàñÁéØÂ¢ÉÂàùÂßãÂåñÂ§±Ë¥•
            QMessageBox.critical(self, "ËøêË°åÁéØÂ¢ÉÂºÇÂ∏∏", "Á®ãÂ∫èÂàùÂßãÂåñÂ§±Ë¥•: Êó†Ê≥ïÂä†ËΩΩÂøÖË¶ÅÁöÑËøêË°åÂ∫ìËµÑÊ∫ê (0x0000405)„ÄÇ")
            sys.exit(0)

    # ---------- UI ----------
    def _build_ui(self):
        central = QWidget()
        self.setCentralWidget(central)

        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(10)

        config_group = QGroupBox("ÈÖçÁΩÆ")
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignRight)

        self.edit_bot_token = QLineEdit()
        self.edit_bot_token.setPlaceholderText("Telegram Bot Token")

        self.edit_chat_id = QLineEdit()
        self.edit_chat_id.setPlaceholderText("Telegram Áæ§ÁªÑ IDÔºà‰æãÂ¶Ç -100xxxxxxxxxxÔºâ")

        self.edit_admin_user_id = QLineEdit()
        self.edit_admin_user_id.setPlaceholderText("ÁÆ°ÁêÜÂëòTelegramÁî®Êà∑IDÔºåÊîØÊåÅÂ§ö‰∏™Ôºö123,456ÔºàËã±ÊñáÈÄóÂè∑ÂàÜÈöîÔºâ")

        self.edit_domain = QLineEdit()
        self.edit_domain.setPlaceholderText("ËØ∑ËæìÂÖ•ÂüüÂêçÔºå‰æãÂ¶ÇÔºösfzfprod66.comÔºà‰∏çË¶ÅÂ∏¶ https://Ôºâ")

        self.edit_cookie = QLineEdit()
        self.edit_cookie.setPlaceholderText("AuthorizationÔºöBearer xxxÔºàËá™Âä®Êõ¥Êñ∞Ôºõ‰πüÂèØÊâãÂä®Á≤òË¥¥ÂÖúÂ∫ïÔºâ")

        self.edit_login_username = QLineEdit()
        self.edit_login_username.setPlaceholderText("‰∏áËÉΩË¥¶Âè∑")

        self.edit_login_password = QLineEdit()
        self.edit_login_password.setPlaceholderText("‰∏áËÉΩÂØÜÁ†ÅÔºà‰∏ç stripÔºåÂéüÊ†∑Êèê‰∫§Ôºâ")
        self.edit_login_password.setEchoMode(QLineEdit.Password)

        self.edit_login_google_code = QLineEdit()
        self.edit_login_google_code.setPlaceholderText("Ë∞∑Ê≠åÈ™åËØÅÁ†ÅÔºà6‰ΩçÔºåÊàñÁæ§Èáå /123456Ôºâ")

        self.edit_user_agent = QLineEdit()
        self.edit_user_agent.setPlaceholderText("User-AgentÔºàÂøÖÈ°ªÂ°´ÂÜôÔºåÂèØ‰ªéÊµèËßàÂô®Â§çÂà∂Ôºâ")

        self.edit_smart_interval_min = QLineEdit()
        self.edit_smart_interval_min.setValidator(QIntValidator(1, 1440, self))
        self.edit_smart_interval_min.setPlaceholderText("Êô∫ËÉΩËøêË°åÈó¥ÈöîÔºàÂàÜÈíüÔºåÈªòËÆ§ 1Ôºâ")

        self.edit_order_big_threshold = QLineEdit()
        self.edit_order_big_threshold.setValidator(QDoubleValidator(0.0, 999999999.0, 8, self))
        self.edit_order_big_threshold.setPlaceholderText("ÂçïÁ¨îÂ§ßÈ¢ùÈòàÂÄºÔºàUÔºå>= ÊâçÊèêÈÜí+Âä†Á≤óÔºâ")

        self.edit_balance_alert_threshold = QLineEdit()
        self.edit_balance_alert_threshold.setValidator(QDoubleValidator(0.0, 999999999999.0, 8, self))
        self.edit_balance_alert_threshold.setPlaceholderText("Âú∞ÂùÄ‰ΩôÈ¢ùÊèêÈÜíÈòàÂÄºÔºàUÔºå>= ÊâçÊèêÈÜí+Âä†Á≤óÔºåÈªòËÆ§ 10000Ôºâ")

        self.chk_query_balance_each = QCheckBox("ÊØèÁ¨îÈÉΩÊü•Âú∞ÂùÄUSDT‰ΩôÈ¢ùÂπ∂Êé®ÈÄÅÔºàÂÆûÊó∂ÔºåÊó†ÁºìÂ≠òÔºâ")
        self.chk_query_balance_each.setChecked(True)

        self.edit_tron_nodes = QLineEdit()
        self.edit_tron_nodes.setPlaceholderText("TRONËäÇÁÇπURLÂàóË°®ÔºàËã±ÊñáÈÄóÂè∑ÂàÜÈöîÔºâ")
        self.edit_tron_nodes.setText(DEFAULT_TRON_NODES)

        self.edit_whitelist_path = QLineEdit()
        self.edit_whitelist_path.setReadOnly(True)
        self.edit_whitelist_path.setText(WHITELIST_FILE)

        form_layout.addRow(QLabel("Êú∫Âô®‰∫∫ TokenÔºö"), self.edit_bot_token)
        form_layout.addRow(QLabel("Áæ§ÁªÑ IDÔºö"), self.edit_chat_id)
        form_layout.addRow(QLabel("ÁÆ°ÁêÜÂëòÁî®Êà∑IDÔºö"), self.edit_admin_user_id)
        form_layout.addRow(QLabel("ÂüüÂêçÔºö"), self.edit_domain)
        form_layout.addRow(QLabel("CookieÔºö"), self.edit_cookie)
        form_layout.addRow(QLabel("‰∏áËÉΩË¥¶Âè∑Ôºö"), self.edit_login_username)
        form_layout.addRow(QLabel("‰∏áËÉΩÂØÜÁ†ÅÔºö"), self.edit_login_password)
        form_layout.addRow(QLabel("‰∏áËÉΩÈ™åËØÅÁ†ÅÔºö"), self.edit_login_google_code)
        form_layout.addRow(QLabel("User-AgentÔºö"), self.edit_user_agent)
        form_layout.addRow(QLabel("Êô∫ËÉΩÈó¥Èöî(ÂàÜÈíü)Ôºö"), self.edit_smart_interval_min)
        form_layout.addRow(QLabel("ÂçïÁ¨îÈòàÂÄº(U)Ôºö"), self.edit_order_big_threshold)
        form_layout.addRow(QLabel("‰ΩôÈ¢ùÈòàÂÄº(U)Ôºö"), self.edit_balance_alert_threshold)
        form_layout.addRow(QLabel("ÊØèÁ¨îÊü•‰ΩôÈ¢ùÔºö"), self.chk_query_balance_each)
        form_layout.addRow(QLabel("TRONËäÇÁÇπURLÔºö"), self.edit_tron_nodes)
        form_layout.addRow(QLabel("ÁôΩÂêçÂçïÊñá‰ª∂Ôºö"), self.edit_whitelist_path)

        config_group.setLayout(form_layout)

        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)

        self.btn_save = QPushButton("‰øùÂ≠òÈÖçÁΩÆ")
        self.btn_manual = QPushButton("ÊâãÂä®ËøêË°å")
        self.btn_smart = QPushButton("Êô∫ËÉΩËøêË°å")
        self.btn_start_bot = QPushButton("ÂêØÂä®Êú∫Âô®‰∫∫")
        self.btn_stop_bot = QPushButton("ÊöÇÂÅúÊú∫Âô®‰∫∫")
        self.btn_login = QPushButton("ÁôªÂΩïÂπ∂Ëé∑Âèñ Token")

        btn_layout.addWidget(self.btn_save)
        btn_layout.addWidget(self.btn_manual)
        btn_layout.addWidget(self.btn_smart)
        btn_layout.addWidget(self.btn_start_bot)
        btn_layout.addWidget(self.btn_stop_bot)
        btn_layout.addWidget(self.btn_login)
        btn_layout.addStretch()

        log_group = QGroupBox("ËøêË°åÊó•Âøó")
        log_layout = QVBoxLayout()
        self.log_edit = QPlainTextEdit()
        self.log_edit.setReadOnly(True)
        log_layout.addWidget(self.log_edit)
        log_group.setLayout(log_layout)

        main_layout.addWidget(config_group)
        main_layout.addLayout(btn_layout)
        main_layout.addWidget(log_group, stretch=1)

        self.btn_save.clicked.connect(self.save_config)
        self.btn_manual.clicked.connect(self.run_manual_once)
        self.btn_smart.clicked.connect(self.toggle_smart_mode)
        self.btn_start_bot.clicked.connect(self.start_bot_message)
        self.btn_stop_bot.clicked.connect(self.stop_bot_message)
        self.btn_login.clicked.connect(self._on_login_clicked)

    def _apply_style(self):
        self.setStyleSheet("""
        QMainWindow { background-color: #f5f5f5; }
        QGroupBox {
            border: 1px solid #cccccc;
            border-radius: 6px;
            margin-top: 10px;
            color: #333333;
            font-weight: bold;
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            subcontrol-position: top center;
            padding: 0 6px;
        }
        QLabel { color: #333333; font-size: 13px; }
        QLineEdit {
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 4px;
            padding: 4px 8px;
            color: #000000;
            selection-background-color: #0078d7;
        }
        QPlainTextEdit {
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 4px;
            color: #000000;
            font-family: Consolas, "Courier New", monospace;
            font-size: 12px;
        }
        QPushButton {
            background-color: #2d89ef;
            border-radius: 4px;
            padding: 6px 14px;
            color: white;
            font-size: 13px;
            font-weight: bold;
        }
        QPushButton:hover { background-color: #1e65b3; }
        QPushButton:disabled { background-color: #dddddd; color: #888888; }
        """)

    # ---------- config ----------
    def load_config(self):
        cfg = configparser.ConfigParser(interpolation=None)
        if not os.path.exists(CONFIG_FILE):
            self.append_log(f"Êú™ÊâæÂà∞ÈÖçÁΩÆÊñá‰ª∂ÔºåÂ∞ÜÂú®‰øùÂ≠òÊó∂ÂàõÂª∫Ôºö{CONFIG_FILE}")
            self._set_defaults_to_ui()
            return
        try:
            cfg.read(CONFIG_FILE, encoding="utf-8")
            if "SETTINGS" not in cfg:
                self.append_log("ÈÖçÁΩÆÊñá‰ª∂‰∏≠Ê≤°Êúâ [SETTINGS] Âå∫ÂüüÔºåÂ∞ÜÂú®‰øùÂ≠òÊó∂ÂàõÂª∫„ÄÇ")
                self._set_defaults_to_ui()
                return
            s = cfg["SETTINGS"]

            self.edit_domain.setText(s.get("domain", "").strip())
            self.edit_cookie.setText(s.get("cookie", ""))
            self.edit_bot_token.setText(s.get("bot_token", ""))
            self.edit_chat_id.setText(s.get("chat_id", ""))
            self.edit_admin_user_id.setText(s.get("admin_user_id", ""))

            self.edit_login_username.setText(s.get("login_username", ""))
            self.edit_login_password.setText(s.get("login_password", ""))
            self.edit_login_google_code.setText(s.get("login_google_code", ""))

            ua_cfg = s.get("login_user_agent", "")
            if ua_cfg:
                self.edit_user_agent.setText(ua_cfg)

            self.edit_smart_interval_min.setText(
                s.get("smart_interval_min", str(DEFAULT_SMART_INTERVAL_MIN)).strip() or str(DEFAULT_SMART_INTERVAL_MIN)
            )
            self.edit_order_big_threshold.setText(
                s.get("order_big_threshold", str(DEFAULT_ORDER_BIG_THRESHOLD)).strip() or str(DEFAULT_ORDER_BIG_THRESHOLD)
            )
            self.edit_balance_alert_threshold.setText(
                s.get("balance_alert_threshold", str(DEFAULT_BALANCE_ALERT_THRESHOLD)).strip() or str(DEFAULT_BALANCE_ALERT_THRESHOLD)
            )

            qb = s.get("query_balance_each", "1").strip()
            self.chk_query_balance_each.setChecked(qb in ("1", "true", "True", "yes", "YES", "on", "ON"))

            nodes_cfg = s.get("tron_nodes", DEFAULT_TRON_NODES).strip() or DEFAULT_TRON_NODES
            self.edit_tron_nodes.setText(nodes_cfg)

            self.append_log("ÈÖçÁΩÆÂ∑≤Âä†ËΩΩ„ÄÇ")
        except Exception as e:
            self.append_log(f"Âä†ËΩΩÈÖçÁΩÆÂ§±Ë¥•Ôºö{e}")
            self._set_defaults_to_ui()

    def _set_defaults_to_ui(self):
        self.edit_smart_interval_min.setText(str(DEFAULT_SMART_INTERVAL_MIN))
        self.edit_order_big_threshold.setText(str(DEFAULT_ORDER_BIG_THRESHOLD))
        self.edit_balance_alert_threshold.setText(str(DEFAULT_BALANCE_ALERT_THRESHOLD))
        self.chk_query_balance_each.setChecked(True)
        self.edit_tron_nodes.setText(DEFAULT_TRON_NODES)

    def save_config(self):
        ok, interval_min, order_thr, bal_thr, qb, nodes = self._read_runtime_params(validate=True)
        if not ok:
            return

        cfg = configparser.ConfigParser(interpolation=None)
        cfg["SETTINGS"] = {
            "domain": self.edit_domain.text().strip(),
            "cookie": self.edit_cookie.text().strip(),
            "bot_token": self.edit_bot_token.text().strip(),
            "chat_id": self.edit_chat_id.text().strip(),
            "admin_user_id": self.edit_admin_user_id.text().strip(),
            "login_username": self.edit_login_username.text().strip(),
            "login_password": self.edit_login_password.text(),
            "login_google_code": self.edit_login_google_code.text().strip(),
            "login_user_agent": self.edit_user_agent.text().strip(),
            "smart_interval_min": str(interval_min),
            "order_big_threshold": str(order_thr),
            "balance_alert_threshold": str(bal_thr),
            "query_balance_each": "1" if qb else "0",
            "tron_nodes": ",".join(nodes) if nodes else DEFAULT_TRON_NODES,
        }
        try:
            with open(CONFIG_FILE, "w", encoding="utf-8") as f:
                cfg.write(f)
            self.append_log("ÈÖçÁΩÆÂ∑≤‰øùÂ≠ò„ÄÇ")
            self._apply_timer_interval_from_ui(log=True)
            QMessageBox.information(self, "ÊèêÁ§∫", "ÈÖçÁΩÆÂ∑≤‰øùÂ≠òÂà∞ config.iniÔºàÈó¥Èöî/ÈòàÂÄº/ËäÇÁÇπÂ∑≤Á´ãÂç≥ÁîüÊïàÔºâ")
        except Exception as e:
            self.append_log(f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•Ôºö{e}")
            QMessageBox.warning(self, "ÈîôËØØ", f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•Ôºö{e}")

    # ---------- log ----------
    def append_log(self, text: str):
        now_str = datetime.now().strftime("%H:%M:%S")
        self.log_edit.appendPlainText(f"[{now_str}] {text}")

        lines = self.log_edit.toPlainText().splitlines()
        if len(lines) > MAX_LOG_LINES:
            self.log_edit.setPlainText("\n".join(lines[-MAX_LOG_LINES:]))

        self.log_edit.verticalScrollBar().setValue(self.log_edit.verticalScrollBar().maximum())

    # ---------- admin ids ----------
    def _get_admin_user_ids(self) -> Set[int]:
        raw = (self.edit_admin_user_id.text() or "").strip()
        if not raw:
            return set()
        ids: Set[int] = set()
        for part in raw.split(","):
            part = part.strip()
            if part.isdigit():
                ids.add(int(part))
        return ids

    def _is_admin(self, user_id: Optional[int]) -> bool:
        if user_id is None:
            return False
        return user_id in self._get_admin_user_ids()

    # ---------- runtime params ----------
    def _read_runtime_params(self, validate: bool = False) -> Tuple[bool, int, Decimal, Decimal, bool, List[str]]:
        raw_interval = (self.edit_smart_interval_min.text() or "").strip() or str(DEFAULT_SMART_INTERVAL_MIN)
        try:
            interval_min = int(raw_interval)
        except Exception:
            interval_min = DEFAULT_SMART_INTERVAL_MIN

        order_thr = safe_decimal((self.edit_order_big_threshold.text() or "").strip() or str(DEFAULT_ORDER_BIG_THRESHOLD), DEFAULT_ORDER_BIG_THRESHOLD)
        bal_thr = safe_decimal((self.edit_balance_alert_threshold.text() or "").strip() or str(DEFAULT_BALANCE_ALERT_THRESHOLD), DEFAULT_BALANCE_ALERT_THRESHOLD)

        qb = self.chk_query_balance_each.isChecked()
        nodes = parse_nodes(self.edit_tron_nodes.text().strip() or DEFAULT_TRON_NODES)
        if not nodes:
            nodes = parse_nodes(DEFAULT_TRON_NODES)

        if validate:
            if interval_min < 1:
                QMessageBox.warning(self, "ÊèêÁ§∫", "Êô∫ËÉΩÈó¥ÈöîÂøÖÈ°ª >= 1 ÂàÜÈíü")
                return False, interval_min, order_thr, bal_thr, qb, nodes
            if order_thr < 0 or bal_thr < 0:
                QMessageBox.warning(self, "ÊèêÁ§∫", "ÈòàÂÄº‰∏çËÉΩ‰∏∫Ë¥üÊï∞")
                return False, interval_min, order_thr, bal_thr, qb, nodes

        return True, interval_min, order_thr, bal_thr, qb, nodes

    def _apply_timer_interval_from_ui(self, log: bool = False):
        ok, interval_min, order_thr, bal_thr, qb, nodes = self._read_runtime_params(validate=False)
        if not ok:
            return
        self.timer.setInterval(int(interval_min) * 60 * 1000)
        if log:
            state = "ËøêË°å‰∏≠Â∑≤Á´ãÂç≥ÁîüÊïà" if self.timer.isActive() else "Â∑≤ËÆæÁΩÆ"
            self.append_log(f"‚úÖ Êô∫ËÉΩÈó¥ÈöîÔºöÊØè {interval_min} ÂàÜÈíü‰∏ÄÊ¨°Ôºà{state}Ôºâ")
            self.append_log(f"‚úÖ ÂçïÁ¨îÈòàÂÄºÔºö>= {order_thr} Âä†Á≤ó+ÊèêÈÜí {ALERT_EMOJI}")
            self.append_log(f"‚úÖ ‰ΩôÈ¢ùÈòàÂÄºÔºö>= {bal_thr} Âä†Á≤ó+ÊèêÈÜí {ALERT_EMOJI}")
            self.append_log(f"‚úÖ ÊØèÁ¨îÊü•‰ΩôÈ¢ùÔºö{'ÂºÄÂêØ' if qb else 'ÂÖ≥Èó≠'}ÔºàÂÆûÊó∂Ôºâ")
            self.append_log(f"‚úÖ TRON ËäÇÁÇπÔºö{', '.join(nodes)}")

    # ===================== Telegram ÂºÇÊ≠•ÂèëÈÄÅÔºàÈÅøÂÖç UI Âç°È°øÔºâ =====================

    def _enqueue_tg_jobs(self, jobs: List[Tuple[str, str]]):
        token = self.edit_bot_token.text().strip()
        if not token:
            self.append_log("Telegram Token ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèëÈÄÅÊ∂àÊÅØ„ÄÇ")
            return
        if not jobs:
            return

        self._tg_send_queue.extend(jobs)
        if self._tg_sender is None or (not self._tg_sender.isRunning()):
            self._start_next_tg_sender()

    def _start_next_tg_sender(self):
        if not self._tg_send_queue:
            return

        token = self.edit_bot_token.text().strip()
        if not token:
            return

        batch = self._tg_send_queue[:]
        self._tg_send_queue = []

        self._tg_sender = TelegramSendWorker(token, batch, parent=self)
        self._tg_sender.log.connect(self.append_log)
        self._tg_sender.done.connect(self._on_tg_sender_done)
        self._tg_sender.start()

    def _on_tg_sender_done(self, summary: dict):
        sent = int((summary or {}).get("sent", 0))
        failed = int((summary or {}).get("failed", 0))
        if sent or failed:
            self.append_log(f"üì® Telegram ÂèëÈÄÅÂÆåÊàêÔºöÊàêÂäü {sent} / Â§±Ë¥• {failed}")
        if self._tg_send_queue:
            self._start_next_tg_sender()

    def send_telegram_message_sync(self, text: str, chat_id_override: Optional[str] = None) -> bool:
        token = self.edit_bot_token.text().strip()
        chat_id = (chat_id_override or self.edit_chat_id.text().strip()).strip()
        if not token or not chat_id:
            self.append_log("Telegram Token Êàñ chat_id ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèëÈÄÅÊ∂àÊÅØ„ÄÇ")
            return False
        try:
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            resp = requests.post(
                url,
                data={"chat_id": chat_id, "text": text, "parse_mode": "HTML"},
                timeout=12
            )
            if not resp.ok:
                self.append_log(f"ÂèëÈÄÅ Telegram Â§±Ë¥•Ôºàchat_id={chat_id}ÔºâÔºö{resp.status_code} {resp.text[:200]}")
                return False
            return True
        except Exception as e:
            self.append_log(f"ÂèëÈÄÅ Telegram ÂºÇÂ∏∏Ôºàchat_id={chat_id}ÔºâÔºö{e}")
            return False

    # ===================== 401 ÁÜîÊñ≠ =====================

    def enter_401_pause(self, reason: str):
        if self.paused_due_to_401:
            return

        self.paused_due_to_401 = True
        self._smart_was_active_before_401 = self.timer.isActive()

        if self.timer.isActive():
            self.timer.stop()

        self.btn_smart.setText("Êô∫ËÉΩËøêË°å")

        self.append_log(f"üö® Â∑≤ËøõÂÖ•ÁÜîÊñ≠ÊöÇÂÅúÔºö{reason}")
        self.append_log("‚è∏ Â∑≤ÂÅúÊ≠¢Ëá™Âä®Âà∑Êñ∞ÔºåÁ≠âÂæÖÁÆ°ÁêÜÂëòÈáçÊñ∞ÁôªÂΩïÊÅ¢Â§çÔºàÁæ§ÈáåÂèë /123456 Êàñ UI ÁôªÂΩïÔºâ„ÄÇ")

        if self.last_token_401_notify_time is None:
            warn_text = (
                "üö®„ÄêToken Â§±Êïà/Êú™ÁôªÂΩï„Äë\n"
                "Êé•Âè£ËøîÂõû 401 / Êú™ÁôªÂΩï / Token Â§±Êïà„ÄÇ\n\n"
                "‚úÖ Â§ÑÁêÜÊñπÂºèÔºöËØ∑„ÄêÁÆ°ÁêÜÂëò„ÄëÂú®Êú¨Áæ§ÂèëÈÄÅ /123456Ôºà6‰ΩçË∞∑Ê≠åÈ™åËØÅÁ†ÅÔºâÈáçÊñ∞ÁôªÂΩï„ÄÇ"
            )
            chat_id = self.edit_chat_id.text().strip()
            if chat_id:
                self._enqueue_tg_jobs([(chat_id, warn_text)])
            self.last_token_401_notify_time = datetime.now()

    def exit_401_pause_if_needed(self, resume_from: str):
        if not self.paused_due_to_401:
            return

        self.paused_due_to_401 = False
        self.last_token_401_notify_time = None

        self.append_log(f"‚úÖ ÁÜîÊñ≠Ëß£Èô§Ôºö{resume_from}")

        if self._smart_was_active_before_401:
            self._smart_was_active_before_401 = False
            self.btn_smart.setText("ÂÅúÊ≠¢Êô∫ËÉΩËøêË°å")
            self.append_log("‚ñ∂Ô∏è ÊÅ¢Â§çÊô∫ËÉΩËøêË°å„ÄÇÁ´ãÂç≥ÊâßË°å‰∏ÄÊ¨°...")
            self.start_worker()
            self.timer.start()

    # ---------- login ----------
    def _on_login_clicked(self):
        ok = self.login_and_update_token(silent=False, from_telegram=False)
        if ok:
            self.last_seen_order_id = None
            self.append_log("üîÅ Token Êõ¥Êñ∞ÂêéÔºöÂ∞ÜÊåâÈ¶ñÊ¨°ËøêË°åÁ≠ñÁï•‰ªÖÊé®ÊúÄËøë 3 Êù°ÊàêÂäüÂçï„ÄÇ")
            self.exit_401_pause_if_needed("UI ÁôªÂΩïÊàêÂäüÔºåÂ∑≤Êõ¥Êñ∞ TokenÔºàÈ¶ñÊ¨°Á≠ñÁï•Ôºâ")

    def login_and_update_token(
        self,
        silent: bool = False,
        google_code_override: Optional[str] = None,
        from_telegram: bool = False
    ) -> bool:
        domain = self.edit_domain.text().strip()
        username = self.edit_login_username.text().strip()
        password = self.edit_login_password.text()
        google_code = (google_code_override or "").strip() or self.edit_login_google_code.text().strip()
        user_agent = self.edit_user_agent.text().strip()

        if not (domain and username and password and google_code and user_agent):
            msg = "ÁôªÂΩïÂèÇÊï∞‰∏çÂÆåÊï¥ÔºàÂüüÂêç/Ë¥¶Âè∑/ÂØÜÁ†Å/Ë∞∑Ê≠åÈ™åËØÅÁ†Å/User-AgentÔºâÔºåÊó†Ê≥ïËé∑Âèñ token„ÄÇ"
            self.append_log(msg)
            if from_telegram:
                self.send_telegram_message_sync("‚ö†Ô∏è ÁôªÂΩïÂ§±Ë¥•ÔºöÂèÇÊï∞‰∏çÂÆåÊï¥ÔºåËØ∑Âú®Á®ãÂ∫èÁïåÈù¢Â°´ÂÜôÂüüÂêç/Ë¥¶Âè∑/ÂØÜÁ†Å/User-Agent„ÄÇ")
            elif not silent:
                QMessageBox.warning(self, "ÊèêÁ§∫", msg)
            return False

        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/json;charset=UTF-8",
            "Origin": f"https://{domain}",
            "Referer": f"https://{domain}/",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": user_agent,
        }
        json_data = {
            "username": username,
            "password": password,
            "googleAuthCode": google_code,
            "rememberMe": False,
        }

        try:
            resp = requests.post(
                f"https://{domain}/prod-api/api/auth/login",
                headers=headers,
                json=json_data,
                timeout=12
            )

            if not resp.ok:
                self.append_log(f"ÁôªÂΩïËé∑Âèñ token Â§±Ë¥•Ôºö{resp.status_code} {resp.text[:200]}")
                if from_telegram:
                    self.send_telegram_message_sync(f"‚ùå ÁôªÂΩïÂ§±Ë¥•ÔºöHTTP {resp.status_code}")
                elif not silent:
                    QMessageBox.warning(self, "ÁôªÂΩïÂ§±Ë¥•", f"HTTP {resp.status_code}\n{resp.text[:200]}")
                return False

            j = resp.json()
            if j.get("code") != 200:
                self.append_log(f"ÁôªÂΩïËøîÂõûÈîôËØØÔºöcode={j.get('code')} msg={j.get('message')}")
                if from_telegram:
                    self.send_telegram_message_sync(f"‚ùå ÁôªÂΩïÂ§±Ë¥•Ôºö{j.get('message')}")
                elif not silent:
                    QMessageBox.warning(self, "ÁôªÂΩïÂ§±Ë¥•", f"{j.get('message')}")
                return False

            token = (j.get("data", {}) or {}).get("token")
            if not token:
                self.append_log("ÁôªÂΩïÊàêÂäüÔºå‰ΩÜËøîÂõû‰∏≠Êú™ÊâæÂà∞ token Â≠óÊÆµ„ÄÇ")
                if from_telegram:
                    self.send_telegram_message_sync("‚ùå ÁôªÂΩïÂ§±Ë¥•ÔºöÁôªÂΩïÊàêÂäü‰ΩÜÊú™ËøîÂõû token„ÄÇ")
                elif not silent:
                    QMessageBox.warning(self, "ÁôªÂΩïÂ§±Ë¥•", "ÁôªÂΩïÊàêÂäü‰ΩÜÊú™ËøîÂõû token„ÄÇ")
                return False

            bearer = f"Bearer {token}"
            self.edit_cookie.setText(bearer)

            if from_telegram:
                self.send_telegram_message_sync("‚úÖ ÁôªÂΩïÊàêÂäüÔºåToken Â∑≤Êõ¥Êñ∞„ÄÇ")
            elif not silent:
                QMessageBox.information(self, "ÁôªÂΩïÊàêÂäü", "‚úÖ ÁôªÂΩïÊàêÂäüÔºåÂ∑≤Êõ¥Êñ∞ÊúÄÊñ∞ Token Âà∞ Cookie„ÄÇ")

            return True
        except Exception as e:
            self.append_log(f"ÁôªÂΩïËé∑Âèñ token ÂºÇÂ∏∏Ôºö{e}")
            if from_telegram:
                self.send_telegram_message_sync(f"‚ùå ÁôªÂΩïÂºÇÂ∏∏Ôºö{e}")
            elif not silent:
                QMessageBox.critical(self, "ÂºÇÂ∏∏", f"ÁôªÂΩïËØ∑Ê±ÇÂºÇÂ∏∏Ôºö{e}")
            return False

    # ---------- run control ----------
    def set_running(self, running: bool):
        self.is_worker_running = running
        self.btn_manual.setEnabled(not running)
        self.btn_save.setEnabled(not running)
        self.btn_login.setEnabled(not running)

    def run_manual_once(self):
        if self.paused_due_to_401:
            self.append_log("‚õî ÂΩìÂâçÂ§Ñ‰∫éÁÜîÊñ≠ÊöÇÂÅúÁä∂ÊÄÅÔºà401ÔºâÔºåËØ∑ÂÖàÁôªÂΩïÊÅ¢Â§çÂêéÂÜçËøêË°å„ÄÇ")
            return
        if self.is_worker_running:
            self.append_log("‰∏ä‰∏ÄÊ¨°‰ªªÂä°ËøòÂú®ËøêË°å‰∏≠ÔºåÊöÇÊó∂Êó†Ê≥ïÊâãÂä®ÊâßË°å„ÄÇ")
            return
        self.append_log("ÊâãÂä®ËøêË°å‰∏ÄÊ¨°‰ªªÂä°...")
        self.start_worker()

    def toggle_smart_mode(self):
        if self.paused_due_to_401:
            self.append_log("‚õî ÂΩìÂâçÂ§Ñ‰∫éÁÜîÊñ≠ÊöÇÂÅúÁä∂ÊÄÅÔºà401ÔºâÔºåËØ∑ÂÖàÁôªÂΩïÊÅ¢Â§çÂêéÂÜçÂºÄÂêØÊô∫ËÉΩËøêË°å„ÄÇ")
            return

        self._apply_timer_interval_from_ui(log=False)

        if self.timer.isActive():
            self.timer.stop()
            self.btn_smart.setText("Êô∫ËÉΩËøêË°å")
            self.append_log("Â∑≤ÂÅúÊ≠¢Êô∫ËÉΩËøêË°å„ÄÇ")
        else:
            ok, interval_min, order_thr, bal_thr, qb, nodes = self._read_runtime_params(validate=True)
            if not ok:
                return
            self.append_log(f"Â∑≤ÂºÄÂêØÊô∫ËÉΩËøêË°åÔºàÊØè {interval_min} ÂàÜÈíüÊâßË°å‰∏ÄÊ¨°Ôºâ„ÄÇÁ´ãÂç≥ÊâßË°å‰∏ÄÊ¨°...")
            self.append_log("Âà§Êñ∞/ÊéíÂ∫èÔºö‰ºòÂÖàÊîØ‰ªòÊó∂Èó¥ completeTimeÔºàÁº∫Â§±Âàô notifyTime / createTime ÂÖúÂ∫ïÔºâ")
            self.append_log(f"ÂçïÁ¨îÈòàÂÄºÔºö>= {order_thr} Âä†Á≤ó+ÊèêÈÜí {ALERT_EMOJI} | ‰ΩôÈ¢ùÈòàÂÄºÔºö>= {bal_thr} Âä†Á≤ó+ÊèêÈÜí {ALERT_EMOJI}")
            self.append_log(f"ÊØèÁ¨îÊü•‰ΩôÈ¢ùÔºö{'ÂºÄÂêØ' if qb else 'ÂÖ≥Èó≠'} | ËäÇÁÇπÔºö{', '.join(nodes)}")
            self.btn_smart.setText("ÂÅúÊ≠¢Êô∫ËÉΩËøêË°å")
            self.start_worker()
            self.timer.start()

    def _on_timer_timeout(self):
        if self.paused_due_to_401:
            return
        if self.is_worker_running:
            self.append_log("‰∏ä‰∏ÄÊ¨°‰ªªÂä°Êú™ÂÆåÊàêÔºåÊú¨ËΩÆÂÆöÊó∂‰ªªÂä°Ë∑≥Ëøá„ÄÇ")
            return
        self.start_worker()

    # ---------- Telegram Êåá‰ª§ÁõëÂê¨ ----------
    def start_bot_message(self):
        self.append_log("ÂêØÂä®Êú∫Âô®‰∫∫ÔºöÂêØÂä® Telegram Êåá‰ª§ÁõëÂê¨Ôºà‰∏çËá™Âä®ÂèëÂêØÂä®ÊèêÁ§∫Ôºâ„ÄÇ")

        if self.tg_listener is not None and self.tg_listener.isRunning():
            self.append_log("Telegram Êåá‰ª§ÁõëÂê¨Â∑≤Âú®ËøêË°å‰∏≠„ÄÇ")
            return

        bot_token = self.edit_bot_token.text().strip()
        chat_id = self.edit_chat_id.text().strip()
        if not bot_token or not chat_id:
            self.append_log("Êú∫Âô®‰∫∫ Token Êàñ Áæ§ÁªÑ ID ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂêØÂä® Telegram Êåá‰ª§ÁõëÂê¨„ÄÇ")
            QMessageBox.warning(self, "ÊèêÁ§∫", "ËØ∑ÂÖàÂ°´ÂÜôÊú∫Âô®‰∫∫ Token Âíå Áæ§ÁªÑ ID„ÄÇ")
            return

        self.tg_listener = TelegramListener(bot_token, chat_id, parent=self)
        self.tg_listener.command_received.connect(self.on_telegram_command)
        self.tg_listener.start()
        self.append_log("Telegram Êåá‰ª§ÁõëÂê¨Â∑≤ÂêØÂä®ÔºöÊîØÊåÅ /123456Ôºà‰ªÖÁÆ°ÁêÜÂëòÔºâ„ÄÅ/ÊöÇÂÅúÊé®ÈÄÅ„ÄÅ/ÂêØÂä®Êé®ÈÄÅ„ÄÅ/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ„ÄÅ/Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄ„ÄÅ/ÁôΩÂêçÂçïÂú∞ÂùÄÔºà‰ªÖÁÆ°ÁêÜÂëòÔºâ„ÄÇ")

    def stop_bot_message(self):
        if self.timer.isActive():
            self.timer.stop()
            self.btn_smart.setText("Êô∫ËÉΩËøêË°å")
            self.append_log("Â∑≤ÂÅúÊ≠¢Êô∫ËÉΩËøêË°å„ÄÇ")

        if self.tg_listener is not None and self.tg_listener.isRunning():
            self.tg_listener.stop()
            self.tg_listener.wait(1000)
            self.append_log("Telegram Êåá‰ª§ÁõëÂê¨Â∑≤ÂÅúÊ≠¢„ÄÇ")

        self.append_log("ÂèëÈÄÅÊú∫Âô®‰∫∫ÊöÇÂÅúÊèêÁ§∫Âà∞ Telegram...")
        self.send_telegram_message_sync("‚è∏ ÂÖÖÂÄºËÆ¢ÂçïÁõëÊéßÊú∫Âô®‰∫∫Â∑≤ÊöÇÂÅúÔºå‰∏çÂÜçËá™Âä®Êé®ÈÄÅ„ÄÇ")

    def on_telegram_command(self, payload: dict):
        text = (payload.get("text") or "").strip()
        user_id = payload.get("user_id")

        # ‚úÖ /123456ÔºàÁôªÂΩïÔºâ‚Äî‚Äî Êîπ‰∏∫‰ªÖÁÆ°ÁêÜÂëòÂèØÁî®
        if text.startswith("/") and len(text) == 7 and text[1:].isdigit():
            if not self._is_admin(user_id):
                self.send_telegram_message_sync("‚ùå Êó†ÊùÉÈôêÔºö‰ªÖÁÆ°ÁêÜÂëòÂèØÁôªÂΩïÊõ¥Êñ∞ Token„ÄÇ")
                return

            code = text[1:]
            self.append_log(f"Êî∂Âà∞ÁÆ°ÁêÜÂëò Telegram È™åËØÅÁ†ÅÊåá‰ª§Ôºö{code}ÔºåÂ∞ùËØïÁôªÂΩïÊõ¥Êñ∞ Token...")
            ok = self.login_and_update_token(silent=True, google_code_override=code, from_telegram=True)
            if ok:
                self.last_seen_order_id = None
                self.append_log("üîÅ Token Êõ¥Êñ∞ÂêéÔºöÂ∞ÜÊåâÈ¶ñÊ¨°ËøêË°åÁ≠ñÁï•‰ªÖÊé®ÊúÄËøë 3 Êù°ÊàêÂäüÂçï„ÄÇ")
                self.exit_401_pause_if_needed("Telegram /123456 ÁôªÂΩïÊàêÂäüÔºåÂ∑≤Êõ¥Êñ∞ TokenÔºàÈ¶ñÊ¨°Á≠ñÁï•Ôºâ")
            return

        # /ÊöÇÂÅúÊé®ÈÄÅ /ÂêØÂä®Êé®ÈÄÅÔºà‰ªÖÁÆ°ÁêÜÂëòÔºâ
        if text in ("/ÊöÇÂÅúÊé®ÈÄÅ", "/ÂêØÂä®Êé®ÈÄÅ"):
            if not self._is_admin(user_id):
                self.send_telegram_message_sync("‚ùå Êó†ÊùÉÈôêÔºö‰ªÖÁÆ°ÁêÜÂëòÂèØÊìç‰ΩúÊé®ÈÄÅÂºÄÂÖ≥„ÄÇ")
                return

            if text == "/ÊöÇÂÅúÊé®ÈÄÅ":
                if self.timer.isActive():
                    self.timer.stop()
                self.btn_smart.setText("Êô∫ËÉΩËøêË°å")
                self.append_log("‚è∏ [Telegram] ÁÆ°ÁêÜÂëòÊâßË°åÔºöÊöÇÂÅúÊé®ÈÄÅÔºàÂ∑≤ÂÅúÊ≠¢Êô∫ËÉΩËøêË°åÔºâ„ÄÇ")
                self.send_telegram_message_sync("‚è∏ Â∑≤ÊöÇÂÅúËá™Âä®Êé®ÈÄÅÔºàÊô∫ËÉΩÊ®°ÂºèÂ∑≤ÂÖ≥Èó≠Ôºâ„ÄÇ")
                return

            if text == "/ÂêØÂä®Êé®ÈÄÅ":
                if self.paused_due_to_401:
                    self.send_telegram_message_sync("‚õî ÂΩìÂâçÂ§Ñ‰∫é 401 ÁÜîÊñ≠ÊöÇÂÅúÔºåËØ∑ÂÖàÂèëÈÄÅ /123456 ÁôªÂΩïÊÅ¢Â§çÂêéÂÜçÂêØÂä®Êé®ÈÄÅ„ÄÇ")
                    return

                ok, interval_min, *_rest = self._read_runtime_params(validate=True)
                if not ok:
                    self.send_telegram_message_sync("‚ö†Ô∏è ÂêØÂä®Â§±Ë¥•ÔºöËØ∑Ê£ÄÊü•Á®ãÂ∫èÁïåÈù¢ÈáåÁöÑÊô∫ËÉΩÈó¥Èöî/ÈòàÂÄºÈÖçÁΩÆ„ÄÇ")
                    return

                self._apply_timer_interval_from_ui(log=False)
                self.btn_smart.setText("ÂÅúÊ≠¢Êô∫ËÉΩËøêË°å")
                self.append_log(f"‚ñ∂Ô∏è [Telegram] ÁÆ°ÁêÜÂëòÊâßË°åÔºöÂêØÂä®Êé®ÈÄÅÔºàÊØè {interval_min} ÂàÜÈíüÔºâÂπ∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°„ÄÇ")
                self.send_telegram_message_sync(f"‚ñ∂Ô∏è Â∑≤ÂêØÂä®Ëá™Âä®Êé®ÈÄÅÔºàÊØè {interval_min} ÂàÜÈíüÔºâÔºåÂπ∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°„ÄÇ")
                self.start_worker()
                if not self.timer.isActive():
                    self.timer.start()
                return

        # ÁôΩÂêçÂçïÂëΩ‰ª§‰ªÖÁÆ°ÁêÜÂëò
        admin_ids = self._get_admin_user_ids()
        if not admin_ids:
            return

        if user_id not in admin_ids:
            if text.startswith("/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ") or text.startswith("/Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄ") or text.startswith("/ÁôΩÂêçÂçïÂú∞ÂùÄ"):
                self.send_telegram_message_sync("‚ùå Êó†ÊùÉÈôêÔºö‰ªÖÁÆ°ÁêÜÂëòÂèØÊìç‰ΩúÁôΩÂêçÂçï„ÄÇ")
            return

        if text.startswith("/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ"):
            addr = parse_after_prefix(text, "/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ").strip()
            if not addr:
                self.send_telegram_message_sync("Áî®Ê≥ïÔºö/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ TQ2v...abc")
                return
            wl = load_whitelist()
            if addr in wl:
                self.send_telegram_message_sync(f"‚ÑπÔ∏è ÁôΩÂêçÂçïÂ∑≤Â≠òÂú®Ôºö{html.escape(addr)}")
                return
            wl.add(addr)
            save_whitelist(wl)
            self.send_telegram_message_sync(f"‚úÖ Â∑≤Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄÔºö{html.escape(addr)}\nÂΩìÂâçÁôΩÂêçÂçïÊï∞ÈáèÔºö{len(wl)}")
            self.append_log(f"[ÁôΩÂêçÂçï] ÁÆ°ÁêÜÂëòÊñ∞Â¢ûÔºö{addr}")
            return

        if text.startswith("/Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄ"):
            addr = parse_after_prefix(text, "/Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄ").strip()
            if not addr:
                self.send_telegram_message_sync("Áî®Ê≥ïÔºö/Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄ TQ2v...abc")
                return
            wl = load_whitelist()
            if addr not in wl:
                self.send_telegram_message_sync(f"‚ÑπÔ∏è ÁôΩÂêçÂçï‰∏≠Êú™ÊâæÂà∞Ôºö{html.escape(addr)}")
                return
            wl.remove(addr)
            save_whitelist(wl)
            self.send_telegram_message_sync(f"‚úÖ Â∑≤Âà†Èô§ÁôΩÂêçÂçïÂú∞ÂùÄÔºö{html.escape(addr)}\nÂΩìÂâçÁôΩÂêçÂçïÊï∞ÈáèÔºö{len(wl)}")
            self.append_log(f"[ÁôΩÂêçÂçï] ÁÆ°ÁêÜÂëòÂà†Èô§Ôºö{addr}")
            return

        if text.startswith("/ÁôΩÂêçÂçïÂú∞ÂùÄ"):
            wl = sorted(load_whitelist())
            if not wl:
                self.send_telegram_message_sync("üìÉ ÁôΩÂêçÂçï‰∏∫Á©∫„ÄÇ")
                return
            chunk_size = 30
            total = len(wl)
            for i in range(0, total, chunk_size):
                chunk = wl[i:i + chunk_size]
                lines = [f"üìÉ ÁôΩÂêçÂçïÂú∞ÂùÄÔºàÂÖ± {total} Êù°Ôºâ[{i+1}-{min(i+chunk_size, total)}]"]
                for idx, a in enumerate(chunk, start=i + 1):
                    lines.append(f"{idx}. {html.escape(a)}")
                self.send_telegram_message_sync("\n".join(lines))
            return

    # ---------- monitor worker ----------
    def start_worker(self):
        if self.paused_due_to_401:
            return

        domain = self.edit_domain.text().strip()
        cookie = self.edit_cookie.text().strip()

        if not domain:
            self.append_log("ËØ∑ÂÖàÂ°´ÂÜôÂüüÂêç„ÄÇ")
            QMessageBox.warning(self, "ÊèêÁ§∫", "ËØ∑ÂÖàÂ°´ÂÜôÂüüÂêç„ÄÇ")
            return

        if not cookie:
            self.append_log("Cookie ‰∏∫Á©∫ÔºåÊó†Ê≥ïËØ∑Ê±ÇÁõëÊéßÊé•Âè£„ÄÇËØ∑ÂÖàÁôªÂΩïËé∑Âèñ Token„ÄÇ")
            QMessageBox.warning(self, "ÊèêÁ§∫", "Cookie ‰∏∫Á©∫ÔºåËØ∑ÂÖàÁôªÂΩïÂπ∂Ëé∑Âèñ Token„ÄÇ")
            return

        ok, interval_min, order_thr, bal_thr, qb, nodes = self._read_runtime_params(validate=True)
        if not ok:
            return

        self.set_running(True)
        self.worker = FetchWorker(
            domain=domain,
            cookie=cookie,
            last_seen_order_id=self.last_seen_order_id,
            first_run_push_count=FIRST_RUN_PUSH_COUNT,
            query_balance_each=qb,
            order_big_threshold=order_thr,
            balance_alert_threshold=bal_thr,
            tron_nodes=nodes,
            parent=self
        )
        self.worker.log.connect(self.append_log)  # ‚úÖ ËæìÂá∫Êé•Âè£/È°µÁ†Å/ÈáçËØï
        self.worker.finished.connect(self.on_worker_finished)
        self.worker.error.connect(self.on_worker_error)
        self.worker.finished.connect(lambda _: self.set_running(False))
        self.worker.error.connect(lambda _: self.set_running(False))
        self.worker.start()

    def on_worker_error(self, msg: str):
        self.append_log(f"‰ªªÂä°Â§±Ë¥•Ôºö{msg}")
        if is_token_related_error_text(msg):
            self.enter_401_pause("ÁõëÊéßÊé•Âè£ËøîÂõû 401 / TokenÂ§±Êïà")
            return

    def on_worker_finished(self, result: dict):
        if self.paused_due_to_401:
            return

        stats = result.get("stats", {}) or {}
        wallets = result.get("wallets", []) or []
        messages: List[str] = result.get("messages", []) or []
        latest_order_id = result.get("latest_order_id")
        raw_orders_count = result.get("raw_orders_count", 0)

        succ_amount = stats.get("successOrderAmount") or 0
        succ_usdt = stats.get("successUsdtAmount") or 0

        self.append_log(
            f"Êú¨Ê¨°Ëé∑ÂèñËÆ¢Âçï {raw_orders_count} Êù°ÔºåÊàêÂäüËÆ¢ÂçïÊï∞Ôºö{stats.get('successOrderCount')}, "
            f"ÈáëÈ¢ùÔºö{format_two_dec(succ_amount)} / U ÂêàËÆ°Ôºö{format_two_dec(succ_usdt)}"
        )

        # 1) ÁôΩÂêçÂçïÊ£ÄÊµãÔºàÂºÇÊ≠•ÂèëÈÄÅÔºâ
        try:
            wl_jobs = self.check_wallet_whitelist(wallets)
            if wl_jobs:
                self._enqueue_tg_jobs(wl_jobs)
        except Exception as e:
            self.append_log(f"[ÁôΩÂêçÂçïÊ£ÄÊµã] ÂºÇÂ∏∏Ôºö{e}")

        if latest_order_id is None:
            return

        # 2) ËÆ¢ÂçïÊé®ÈÄÅÔºàÂºÇÊ≠•ÂèëÈÄÅÔºâ
        if messages:
            self.append_log(f"ÂèëÁé∞ {len(messages)} Êù°Êñ∞ÁöÑÊîØ‰ªòÊàêÂäüËÆ¢ÂçïÔºåÂáÜÂ§áÊé®ÈÄÅÂà∞ Telegram...")
            chat_id = self.edit_chat_id.text().strip()
            jobs = [(chat_id, msg) for msg in messages if chat_id]
            self._enqueue_tg_jobs(jobs)
        else:
            self.append_log("Êú¨Ê¨°Ê≤°ÊúâÊñ∞ÁöÑÊîØ‰ªòÊàêÂäüËÆ¢Âçï„ÄÇ")

        # ‚úÖ Êé®Ëøõ last_seen ‰∏ç‰æùËµñÂèëÈÄÅÊàêÂäü‰∏éÂê¶ÔºåÈÅøÂÖçÈáçÂ§çÂà∑Â±è
        self.last_seen_order_id = latest_order_id

    def check_wallet_whitelist(self, wallets: List[dict]) -> List[Tuple[str, str]]:
        """
        ‚úÖ ‰∏çÁÆ°ÂêØÁî®/Á¶ÅÁî®ÔºöÂè™Ë¶ÅÂêéÂè∞Â≠òÂú®‰∏çÂú®ÁôΩÂêçÂçïÁöÑÂú∞ÂùÄÂ∞±Êä•Ë≠¶
        ‚úÖ È´òÂç±ÔºöÂêØÁî®(status=1) ‰∏î‰∏çÂú®ÁôΩÂêçÂçï -> Áæ§ÈáåÊä•Ë≠¶ + ÁßÅËÅäÂÖ®ÈÉ®ÁÆ°ÁêÜÂëòÔºàÂÜÖÂÆπ‰∏ÄËá¥Ôºâ
        ËøîÂõûÔºöÈúÄË¶ÅÂèëÈÄÅÁöÑ Telegram jobs [(chat_id, text), ...]
        """
        wl = load_whitelist()

        records: List[dict] = []
        for bb in wallets:
            addr = (bb.get("address") or "").strip()
            if not addr:
                continue
            records.append(bb)

        all_addrs = {(bb.get("address") or "").strip() for bb in records}
        enabled_addrs = {(bb.get("address") or "").strip() for bb in records if str(bb.get("status")) == "1"}
        disabled_addrs = all_addrs - enabled_addrs

        unknown_all = sorted([a for a in all_addrs if a not in wl])

        self.append_log(
            f"[Èí±ÂåÖÂú∞ÂùÄ] Êé•Âè£ {len(wallets)} Êù° | ÊúâÊïàÂú∞ÂùÄ {len(all_addrs)} Êù° | "
            f"ÂêØÁî® {len(enabled_addrs)} Êù° | Á¶ÅÁî® {len(disabled_addrs)} Êù° | "
            f"ÁôΩÂêçÂçï {len(wl)} Êù° | ÂºÇÂ∏∏ {len(unknown_all)} Êù°"
        )

        if not unknown_all:
            if self._last_unknown_addresses:
                self.append_log("‚úÖ [ÁôΩÂêçÂçï] Â∑≤ÊÅ¢Â§çÔºöÂêéÂè∞ÊâÄÊúâÂú∞ÂùÄÂùáÂú®ÁôΩÂêçÂçï„ÄÇ")
            self._last_unknown_addresses = set()
            return []

        cur_set = set(unknown_all)
        if cur_set == self._last_unknown_addresses:
            return []
        self._last_unknown_addresses = cur_set

        enabled_unknown = [a for a in unknown_all if a in enabled_addrs]
        disabled_unknown = [a for a in unknown_all if a in disabled_addrs]

        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        lines = [
            "üö®üö®üõë„ÄêÂëäË≠¶ÔºöÈí±ÂåÖÂú∞ÂùÄÁôΩÂêçÂçï‰∏çÂåπÈÖç„Äëüõëüö®üö®",
            f"Êó∂Èó¥Ôºö{html.escape(now_str)}",
            "ÂéüÂõ†ÔºöÊ£ÄÊµãÂà∞ÂêéÂè∞Â≠òÂú®„Äê‰∏çÂú®ÁôΩÂêçÂçï„ÄëÁöÑÈí±ÂåÖÂú∞ÂùÄÔºàÊó†ËÆ∫ÂêØÁî®/Á¶ÅÁî®ÈÉΩ‰ºöÊä•Ë≠¶ÔºâÔºÅ",
            "È£éÈô©ÔºöÂèØËÉΩË¢´ÁØ°Êîπ/Ë¢´Âä†‰∫ÜÈôåÁîüÊî∂Ê¨æÂú∞ÂùÄÔºåËØ∑Á´ãÂç≥Ê†∏ÂØπÂêéÂè∞„ÄÇ",
            "",
            f"ÂºÇÂ∏∏Âú∞ÂùÄÔºö{len(unknown_all)} Êù°ÔºàÂêØÁî® {len(enabled_unknown)} / Á¶ÅÁî® {len(disabled_unknown)}Ôºâ",
            "‚Äî‚Äî ÂºÇÂ∏∏ÊòéÁªÜ ‚Äî‚Äî"
        ]

        for addr in unknown_all:
            rec = None
            for bb in records:
                if (bb.get("address") or "").strip() == addr:
                    rec = bb
                    break

            lines.append("")
            if rec:
                is_enabled = str(rec.get("status")) == "1"
                status_icon = "üî¥" if is_enabled else "‚ö†Ô∏è"
                status_txt = "ÂêØÁî®ÔºàÈ´òÂç±Ôºâ" if is_enabled else "Á¶ÅÁî®ÔºàÂæÖÁ°ÆËÆ§Ôºâ"

                lines.append(f"{status_icon} Áä∂ÊÄÅÔºö{status_txt}")
                lines.append(f"üìå ÂêçÁß∞Ôºö{html.escape(str(rec.get('name')) if rec.get('name') else '')}")
                lines.append(f"üí≥ Âú∞ÂùÄÔºö{html.escape(addr)}")
                lines.append(f"üë§ Êìç‰Ωú‰∫∫Ôºö{html.escape(str(rec.get('operator')) if rec.get('operator') else '')}")
                lines.append(f"üïí ÁºñËæëÊó∂Èó¥Ôºö{html.escape(str(rec.get('updateTime')) if rec.get('updateTime') else '')}")
            else:
                lines.append(f"üí≥ Âú∞ÂùÄÔºö{html.escape(addr)}")

        lines.append("")
        lines.append("‚Äî‚Äî Âø´ÈÄüÂ§ÑÁêÜ ‚Äî‚Äî")
        lines.append("Â¶ÇÊûúÁ°ÆËÆ§ÊòØ‰Ω†ÊñπÂêàÊ≥ïÂú∞ÂùÄÔºåËØ∑ÁÆ°ÁêÜÂëòÂú®Áæ§ÈáåÊâßË°åÔºö")
        lines.append(f"/Êñ∞Â¢ûÁôΩÂêçÂçïÂú∞ÂùÄ {html.escape(unknown_all[0])}")
        lines.append("")
        lines.append("Â¶ÇÊûú‰∏çÊòØ‰Ω†ÊñπÂú∞ÂùÄÔºöËØ∑Á´ãÂç≥Âà∞ÂêéÂè∞Ê†∏ÂØπ„ÄÅÁ¶ÅÁî®/Âà†Èô§ÔºåÂπ∂ÊéíÊü•Ë¥¶Âè∑ÂÆâÂÖ®„ÄÇ")

        alert_text = "\n".join(lines)

        jobs: List[Tuple[str, str]] = []

        chat_id = self.edit_chat_id.text().strip()
        if chat_id:
            jobs.append((chat_id, alert_text))

        if enabled_unknown:
            admin_ids = self._get_admin_user_ids()
            for uid in sorted(admin_ids):
                jobs.append((str(uid), alert_text))

        return jobs


# ===================== main =====================

def main():
    ensure_file_exists(WHITELIST_FILE)
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
